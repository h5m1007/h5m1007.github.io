<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leooon Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-30T08:57:52.822Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打造最佳终端环境</title>
    <link href="http://yoursite.com/2020/04/30/best-terminal-configure/"/>
    <id>http://yoursite.com/2020/04/30/best-terminal-configure/</id>
    <published>2020-04-30T08:32:18.000Z</published>
    <updated>2020-04-30T08:57:52.822Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从0开始配置新购MBP</title>
    <link href="http://yoursite.com/2020/04/30/dev-env-configure/"/>
    <id>http://yoursite.com/2020/04/30/dev-env-configure/</id>
    <published>2020-04-30T08:29:45.000Z</published>
    <updated>2020-05-02T09:45:17.589Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>新入手的 mbp，需要重新配置之前前端开发的环境，已经准备同步的内容有：</p><ol><li><p>Safari，Chrome 两大浏览器的历史数据，如浏览记录、书签、密码、拓展插件等等，分别以 iCould 和 Google 账号的同步功能，实现迁移机器数据的完美同步。</p></li><li><p>其它软件的同步工作，如软件之前的配置，安装的插件等等。</p><p> 开发软件列表：</p><ul><li><p>iTerm2：移步<a href="/2020/04/30/best-terminal-configure/">打造最佳终端</a>;</p></li><li><p>幕布：类似于Xmind脑图软件，用登录账号来实现同步已保存至云端的数据；</p></li><li><p>SwitchHosts：本地 hosts 文件修改软件，直接导入已从其它机器导出的配置文件即可；</p></li><li><p>VsCode：重量级软件，开发必备编辑器，同步功能使用 vscode 的 Setting Sync 插件，通过已在 gist 上传的配置文件来<br>实现同步工作，可同步之前已安装插件列表、软件配置等等；</p></li></ul></li><li><p>除了以上软件的配置安装之外，额外的坑还有：</p><ul><li><p>科学上网</p><p>  没有梯子没有条件就创造条件，国内想 download 一些如 brew、pip、乃至于用 git clone 都是基本没速度可言的，针对以上软件参考解决方案如下：</p><p>  <strong>brew</strong>：按照官方安装方式，因GFW的存在，可能会遇到下载不了或没速度，所以得换种方式，</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh &gt;&gt; ~/brew_install.sh</span><br></pre></td></tr></table></figure><p>  修改 brew_install.sh 文件，更换里面的镜像源  </p><p>  <code>BREW_REPO = &quot;https://github.com/Homebrew/brew”</code><br>  ==&gt;<br>  <code>BREW_REPO=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git”</code></p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502172342.png" alt="修改 brew 镜像源"></p><p>  再执行 brew_install.sh 文件，不出意外，<code>brew -v</code> 显示版本号即安装完毕。</p><p>  <strong>pip</strong>：pip 是 python 包管理工具，系统默认自带的 python2.7 安装包里 easy_install.py 是默认安装的，而 pip 需另外安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用国内镜像源：https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class="line">sudo easy_install -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip</span><br></pre></td></tr></table></figure></li><li><p>Git 下载速度</p><p>  单单 Git Clone 个项目速度相当堪忧，解决此类问题，方案有几种：</p><p>  一般的方式是直接绑 hosts ( 可能本地网络原因亦或其它，反正对于我mbp无效，mmp )：</p><p>  查询以下两域名相对本地网络的 <a href="https://www.ipaddress.com" target="_blank" rel="noopener">IP 地址</a> ( 每个人查询到的可能不一 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line"></span><br><span class="line">github.com</span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502172728.png" alt="github.global.ssl.fastly.net"></p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502173014.png" alt="github.com"></p><p>  假设查询到的 IP 地址是：  </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure><p>  写入 <code>/etc/hosts</code> 文件末尾追加</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>  因我已经安装了 SwitchHosts 该软件，直接写入配置文件立即生效。</p><p>  最后需要刷新 DNS</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure><p>  <strong>注</strong>：获取的 IP 因每个人不一样，且时而会更新，所以一旦速度变慢，重复以上步骤进行修改。</p><p>  另一种最直接了当的，借助现成工具实现加速：(<strong>力荐！</strong>)<br>  <a href="https://github.zhlh6.cn/" target="_blank" rel="noopener">Github加速器</a><br>  <a href="https://chrome.google.com/webstore/detail/github加速/kejahdakjmkfddgnifodfnpcklckjjpo" target="_blank" rel="noopener">Chrome插件</a></p></li><li><p>Brew</p><p>  <code>brew install xxx</code>，brew 安装软件速度依旧感人，解决方案仍然修改镜像源，修改 brew、homebrew-core 的项目 git remote 镜像源</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure><p>  最后更新下 brew <code>brew update</code>。</p><p>  还有一种费时费钱，挂代理：</p><p>  假设你已经用了如Shadowsocks，且也搭好服务器，不管是自己的还是自费的VPS。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口1086不一定配置都是一致，按自己配置的修改</span></span><br><span class="line">ALL_PROXY=socks5://127.0.0.1:1086 brew install node</span><br></pre></td></tr></table></figure><p>  每次使用 brew 安装软件时，都需要手动加载代理，想方便的换也可把 <code>export ALL_PROXY=socks5://127.0.0.1:1086</code> 写入 <code>~/.zshrc</code> 终端配置文件里，但不建议这样做，因为可能会影响其它工具的使用。</p></li><li><p>Node</p><p>  建议直接使用 nvm Node版本管理软件，使用官方下载安装方式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br></pre></td></tr></table></figure><p>  下载安装完成后，修改 <code>~/.zshrc</code> 终端配置文件里，往后继续追加</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动终端时调用 nvm 执行文件</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$([ -z "$&#123;XDG_CONFIG_HOME-&#125;" ] &amp;&amp; printf %s "$&#123;HOME&#125;/.nvm" || printf %s "$&#123;XDG_CONFIG_HOME&#125;/nvm")</span>"</span>[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502173809.png" alt="nvm"></p><p>  重启终端，<code>nvm install 12.16.3</code>，安装制定版本 node。</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;新入手的 mbp，需要重新配置之前前端开发的环境，已经准备同步的内容有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Safari，Chrome 两大浏
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数优化相关</title>
    <link href="http://yoursite.com/2020/04/17/learn-from-optimize/"/>
    <id>http://yoursite.com/2020/04/17/learn-from-optimize/</id>
    <published>2020-04-17T08:29:28.000Z</published>
    <updated>2020-04-30T09:55:14.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><ol><li>函数A内部调用函数B，且不附加其它操作</li><li>函数A在函数最后执行阶段调用函数B</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> B();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> C()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="调用帧-调用记录"><a href="#调用帧-调用记录" class="headerlink" title="调用帧 (调用记录)"></a>调用帧 (调用记录)</h3><p>用于存储调用位置与内部变量信息，所有的调用记录形成调用栈。<br>尾调用由于是函数最后一步操作，则不需保留外层fn的调用记录，因为调用位置、内部变量等信息不会再用到，<br>用内层fn的调用记录取代外层fn的调用记录即可。</p><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>只保留内层fn的调用记录，在调用记录只有一项下，极大程度节省内存。</p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>函数递归本身很耗内存，可能存在n*n的调用记录，容易栈溢出，引入尾递归调用后，由于函数最后只存在一个调用记录，<br>所不会出现栈溢出的风险。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 产生n个调用记录，复杂度O(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 尾递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total); <span class="comment">// 始终产生1个调用记录，复杂度O(1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 柯里化尾递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;尾调用&quot;&gt;&lt;a href=&quot;#尾调用&quot; class=&quot;headerlink&quot; title=&quot;尾调用&quot;&gt;&lt;/a&gt;尾调用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数A内部调用函数B，且不附加其它操作&lt;/li&gt;
&lt;li&gt;函数A在函数最后执行阶段调用函数B&lt;/li&gt;
&lt;/ol&gt;
&lt;f
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>各种应用工具类实现</title>
    <link href="http://yoursite.com/2020/04/09/learn-from-js/"/>
    <id>http://yoursite.com/2020/04/09/learn-from-js/</id>
    <published>2020-04-09T08:07:43.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copy1 = &#123; ...&#123;<span class="attr">x</span>: <span class="number">1</span>&#125; &#125;; <span class="comment">// ...&#123;&#125; 解构实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> copy2  = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;); <span class="comment">// object.assign 对象合并实现</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">x</span>: <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// JSON.stringify 序列化对象成字符串再转对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> copy = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> k <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( obj.hasOwnProperty(k) ) &#123;</span><br><span class="line">      copy[k] = <span class="keyword">typeof</span> obj[k] === <span class="string">'object'</span> ? deepCopy(obj[k]) : obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟setInterval"><a href="#模拟setInterval" class="headerlink" title="模拟setInterval"></a>模拟setInterval</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 这里不能用箭头函数，否则拿不到 arguments</span></span><br><span class="line">  <span class="comment">// func</span></span><br><span class="line">  setTimeout( <span class="built_in">arguments</span>.callee, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><h2 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.events = <span class="keyword">this</span>.events || <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addListener( type, fn ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="keyword">this</span>.events.get(type) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events.set(type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit( type ) &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = <span class="keyword">this</span>.events.get(type);</span><br><span class="line"></span><br><span class="line">    handle.apply(<span class="keyword">this</span>, [...arguments].slice(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventBus;</span><br><span class="line"></span><br><span class="line">emitter.addListener(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...arguments);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(<span class="string">'event'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>);</span><br></pre></td></tr></table></figure><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>简易版主要理解实现核心，getter() &amp; setter()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.getElementById(<span class="string">'html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'text'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>, <span class="comment">// 可配置，如对对象key，value进行配置</span></span><br><span class="line">  enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举，如对被循环遍历</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get data'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>( newValue ) &#123;</span><br><span class="line">    input.value = newValue;</span><br><span class="line">    html.innerHTML = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener( <span class="string">'keyup'</span>, e =&gt; &#123;</span><br><span class="line">  obj.text = e.target.value;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p>所参与计算的需要的变量值：</p><ol><li>可视窗口大小：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准浏览器及IE9+ || 标准浏览器及低版本IE || 低版本混杂模式</span></span><br><span class="line"><span class="comment">// jq: $(window).height()</span></span><br><span class="line"><span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure></li><li>窗口顶部与文档顶部间的距离：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jq: $(document).scrollTop();</span></span><br><span class="line"><span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br></pre></td></tr></table></figure></li><li>元素顶部与文档顶部间的距离：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jq: $(el).offset().top</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElTop</span>(<span class="params">el, initValue = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _top = el.offsetTop + initValue;</span><br><span class="line">  <span class="keyword">const</span> parent = el.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( parent !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    _top += parent.clientTop;</span><br><span class="line">    getElTop(parent, _top); <span class="comment">// 尾递归</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">return</span> _top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElTopLoop</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _top = el.offsetTop;</span><br><span class="line">  <span class="keyword">let</span> parent = el.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>( parent !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    _top += parent.offsetTop + parent.clientTop;</span><br><span class="line">    parent = parent.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBoundingClientRect()</span></span><br><span class="line"><span class="keyword">const</span> EL = <span class="built_in">document</span>.getElementById(<span class="string">'#el'</span>);</span><br><span class="line">EL.getBoundingClientRect().top;</span><br></pre></td></tr></table></figure></li></ol><h3 id="场景：判断元素是否进入视区"><a href="#场景：判断元素是否进入视区" class="headerlink" title="场景：判断元素是否进入视区"></a>场景：判断元素是否进入视区</h3><ol><li>方式一：根据元素到文档顶部的距离是否小于当前视口相对于文档顶部的距离</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInSight</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> clientHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  <span class="keyword">const</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">  <span class="keyword">const</span> scrollHeight = clientHeight + scrollTop;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getElTop(el) &lt; scrollHeight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !el.src ) &#123;</span><br><span class="line">    el.src = el.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkImgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.from(imgs).forEach( <span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( isInSight(img) ) &#123;</span><br><span class="line">      loadImg(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, checkImgs, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">window</span>.onload = checkImgs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntersectionObserver</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h2&gt;&lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>知识梳理一</title>
    <link href="http://yoursite.com/2019/06/27/knowledge-combing/"/>
    <id>http://yoursite.com/2019/06/27/knowledge-combing/</id>
    <published>2019-06-27T02:36:10.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol><li><p>for循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// 缓存arr长度，这一步新版本的浏览器已自行实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>forEach<br>es5的forEach，实际性能比for还差</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function">(<span class="params"> value, index </span>) =&gt;</span> &#123;&#125; )</span><br></pre></td></tr></table></figure><ul><li>不能break中断循环，且无法return</li></ul><ol start="3"><li>map<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.map( <span class="function">(<span class="params"> value, index </span>) =&gt;</span> &#123;&#125; )</span><br></pre></td></tr></table></figure></li></ol><ul><li>支持return</li></ul><ol start="4"><li>for-of<br>es6的for-of</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> index <span class="keyword">of</span> arr ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持数组，类数组对象，字符串</li><li>支持break, continue, return</li></ul><ol start="5"><li>for-in<br>遍历对象，可遍历数组但数组的下标会被转成字符串</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  key1: <span class="string">'value1'</span>,</span><br><span class="line">  key2: <span class="string">'value2'</span>,</span><br><span class="line">  key3: <span class="string">'value3'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> key <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;obj[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>退出循环</li></ol><table><thead><tr><th align="center">序号</th><th align="center">方法</th><th align="center">break</th><th align="center">continue</th><th align="center">return</th><th align="center">return true</th><th align="center">return false</th><th align="center">结论</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">for循环</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">√</td></tr><tr><td align="center">2</td><td align="center">Array.forEach()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">×</td></tr><tr><td align="center">3</td><td align="center">for…in</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">√</td></tr><tr><td align="center">4</td><td align="center">Array.map()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">×</td></tr><tr><td align="center">5</td><td align="center">Array.some()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">√</td></tr><tr><td align="center">6</td><td align="center">Array.every()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">成功</td><td align="center">√</td></tr><tr><td align="center">7</td><td align="center">Array.filter()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">×</td></tr></tbody></table><h2 id="Array-reduce"><a href="#Array-reduce" class="headerlink" title="Array.reduce()"></a>Array.reduce()</h2><p>对数组的每一项升序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce( <span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// accumulator 累计器，默认起始值为initialValue</span></span><br><span class="line">  <span class="comment">// currentValue 当前值</span></span><br><span class="line">  <span class="comment">// currentIndex 当前值下标</span></span><br><span class="line">  <span class="comment">// array调用reduce的数组</span></span><br><span class="line">  <span class="comment">// initialValue accumulator默认起始值，当没指定时则以数组第一项为准</span></span><br><span class="line">&#125;, initialValue )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;for循环&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>require</title>
    <link href="http://yoursite.com/2019/06/25/learn-from-requireJs/"/>
    <id>http://yoursite.com/2019/06/25/learn-from-requireJs/</id>
    <published>2019-06-25T07:20:21.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="require-ensure"><a href="#require-ensure" class="headerlink" title="require.ensure()"></a>require.ensure()</h2><ul><li>代码分隔 基于webpack，针对体积大的模块单独导出js文件，用于异步调用，可结合同步代码</li><li>用法：require.ensure( [], fn(), ‘’ )<br>参数1为异步函数的依赖<br>参数2为回调, 异步调用的函数写于这里<br>参数3为chunk命名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步按需加载的方式导出swiper</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getSwiper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">require</span>.ensure(</span><br><span class="line">        [],</span><br><span class="line">        <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">          res(<span class="built_in">require</span>(<span class="string">'xxx/swiper'</span>));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'chunck-swiper'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;require-ensure&quot;&gt;&lt;a href=&quot;#require-ensure&quot; class=&quot;headerlink&quot; title=&quot;require.ensure()&quot;&gt;&lt;/a&gt;require.ensure()&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代码分隔 基于webpa
      
    
    </summary>
    
    
    
      <category term="javascript require" scheme="http://yoursite.com/tags/javascript-require/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 开发记录</title>
    <link href="http://yoursite.com/2019/06/25/learn-from-nodejs/"/>
    <id>http://yoursite.com/2019/06/25/learn-from-nodejs/</id>
    <published>2019-06-25T07:04:45.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs中一些路径相关概念"><a href="#nodejs中一些路径相关概念" class="headerlink" title="nodejs中一些路径相关概念"></a>nodejs中一些路径相关概念</h2><p>__dirname：获得当前执行文件所在目录完整目录名<br>__filename：获得当前执行文件完整绝对路径文件名<br>process.cwd()：获得当前node命令执行目录名<br>path.resolve()：返回相对当前工作目录的绝对路径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nodejs中一些路径相关概念&quot;&gt;&lt;a href=&quot;#nodejs中一些路径相关概念&quot; class=&quot;headerlink&quot; title=&quot;nodejs中一些路径相关概念&quot;&gt;&lt;/a&gt;nodejs中一些路径相关概念&lt;/h2&gt;&lt;p&gt;__dirname：获得当前执行文件
      
    
    </summary>
    
    
    
      <category term="javascript node" scheme="http://yoursite.com/tags/javascript-node/"/>
    
  </entry>
  
  <entry>
    <title>react 开发记录一</title>
    <link href="http://yoursite.com/2019/06/25/learn-from-react/"/>
    <id>http://yoursite.com/2019/06/25/learn-from-react/</id>
    <published>2019-06-25T07:01:28.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="exports-amp-amp-import"><a href="#exports-amp-amp-import" class="headerlink" title="exports &amp;&amp; import"></a>exports &amp;&amp; import</h2><ol><li>module exports export import<br>由于nodejs采用CommonJS模块规范，其中module表示一个对象变量，本身的exports属性是对外接口。因node为每个模块提供一个exports变量，所以有两种模块导出方式：<code>module.exports = { obj }</code> 和 <code>exports.obj = { obj }</code>；<br>而ES6的export和export default，导出对外接口以提供给import导入，需要注意的是：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  import-index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">var</span> &#125; <span class="keyword">from</span> ‘<span class="keyword">export</span>-index’;</span><br></pre></td></tr></table></figure>由export直接导出的，import导入必须是对象且需知变量名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  import-index.js</span></span><br><span class="line"><span class="keyword">import</span> _var <span class="keyword">from</span> ‘<span class="keyword">export</span>-index’;</span><br></pre></td></tr></table></figure><p>而由export default导出的，import导入可以是自定义变量名</p><h2 id="class-A-extends-B"><a href="#class-A-extends-B" class="headerlink" title="class A extends B {}"></a>class A extends B {}</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(params) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super指向父类B的构造函数</span></span><br><span class="line"><span class="comment">但super内部的this指向A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">super</span>(params); <span class="comment">// B.prototype.constructor.call(this, params)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件间的引用"><a href="#组件间的引用" class="headerlink" title="组件间的引用"></a>组件间的引用</h2><p>当子组件调用父组件函数时，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Parent</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./child.jsx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"><span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 这里使用箭头函数，当子组件调用时</span></span><br><span class="line"><span class="comment">// 可以获得当前作用域的this</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">handleFn</span>=<span class="string">&#123;handleFn&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"><span class="keyword">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; handleFn &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div onClick=&#123; () =&gt; handleFn() &#125; /&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="react中的注释："><a href="#react中的注释：" class="headerlink" title="react中的注释："></a>react中的注释：</h2><p>1.单行注释–<br>{/* 注释内容 */} </p><p>2.多行注释–<br>/*<br>注释1<br>注释2<br>*/<br>ps：切记不能用 <code>&lt;!-- 注释 --&gt;</code></p><h2 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123; </span><br><span class="line"><span class="comment">// 只调用一次</span></span><br><span class="line"><span class="keyword">super</span>(props); <span class="comment">// 必须存在 </span></span><br><span class="line">&#125; <span class="comment">// 初始化</span></span><br><span class="line">↓</span><br><span class="line">componentWillMount() &#123; </span><br><span class="line"><span class="comment">// 只调用一次，此时可修改state</span></span><br><span class="line">&#125; <span class="comment">// 组件即将挂载</span></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 第一次 render() &#123;&#125;</span></span><br><span class="line">↓</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">只调用一次，此时真实的DOM已被渲染出来</span><br><span class="line">&#125; <span class="comment">// 组件完成挂载</span></span><br><span class="line">↓</span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line"><span class="comment">// 组件接收到新的props</span></span><br><span class="line"><span class="comment">// 父组件发生render时，子组件调用</span></span><br><span class="line"><span class="comment">// 可用于组件间通信，父组件作为中间层</span></span><br><span class="line">&#125; <span class="comment">// 组件即将接收父组件值</span></span><br><span class="line">↓</span><br><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line"><span class="comment">// 组件是否应当渲染新的props和state</span></span><br><span class="line">&#125; <span class="comment">// 返回false不执行下一个生命周期</span></span><br><span class="line">↓</span><br><span class="line">componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line"><span class="comment">// 接收到新的props和state之后，渲染之前</span></span><br><span class="line">&#125; <span class="comment">// 组件即将更新</span></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 第二次 render() &#123;&#125;</span></span><br><span class="line">↓</span><br><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line"><span class="comment">// 完成新的props和state更新，渲染之后调用</span></span><br><span class="line"><span class="comment">// 此时可访问真实DOM</span></span><br><span class="line">&#125; <span class="comment">// 组件完成更新</span></span><br><span class="line">↓</span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line"><span class="comment">// 组件被移除前调用</span></span><br><span class="line">&#125; <span class="comment">// 组件卸载</span></span><br></pre></td></tr></table></figure><ul><li>在render阶段，只能经 this.prop 和 this.state 访问数据，不能改变状态，不能修改DOM输出</li></ul><h2 id="react-指定位置render"><a href="#react-指定位置render" class="headerlink" title="react 指定位置render"></a>react 指定位置render</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> <span class="title">extend</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'childClass'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( div ) &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(div);</span><br><span class="line">    div.parentNode.removeChild(div);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'childClass'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( !div ) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.className = <span class="string">'childClass'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span>, div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="性能篇"><a href="#性能篇" class="headerlink" title="性能篇"></a>性能篇</h1><ol><li><p>使用 pureComponent<br>内部处理的是浅比较，应用于业务场景，数据变化不复杂的情况</p></li><li><p>defaultProps 初始化组件属性值<br>引入 ``, 避免组件重复渲染</p></li><li><p>展示组件 / 容器组件<br>抽离业务逻辑至容器组件，纯 UI 层面放置展示组件</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'./Layout'</span>; <span class="comment">// 展示组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...业务逻辑 fn</span></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Layout</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出接受展示组件的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;exports-amp-amp-import&quot;&gt;&lt;a href=&quot;#exports-amp-amp-import&quot; class=&quot;headerlink&quot; title=&quot;exports &amp;amp;&amp;amp; import&quot;&gt;&lt;/a&gt;exports &amp;amp;&amp;amp
      
    
    </summary>
    
    
    
      <category term="react" scheme="http://yoursite.com/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>dva</title>
    <link href="http://yoursite.com/2019/06/21/dva/"/>
    <id>http://yoursite.com/2019/06/21/dva/</id>
    <published>2019-06-21T08:39:37.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="DVA"><a href="#DVA" class="headerlink" title="DVA"></a>DVA</h1><hr><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── /dist/                    <span class="comment"># 编译打包后目录</span></span><br><span class="line">├── /src/                     <span class="comment"># 源码目录</span></span><br><span class="line">│ ├── /assets/                <span class="comment"># 静态资源目录</span></span><br><span class="line">│ ├── /components/            <span class="comment"># UI组件目录</span></span><br><span class="line">│ │ ├── /Forbid/              <span class="comment"># 业务相关组件</span></span><br><span class="line">│ │ │ └── forbid.css          </span><br><span class="line">│ │ │ └── index.js            </span><br><span class="line">│ ├── /containers/            <span class="comment"># 容器组件目录</span></span><br><span class="line">│ │ └── Forbid.js             </span><br><span class="line">│ ├── /models/                <span class="comment"># Model 一个模块对应一个model</span></span><br><span class="line">│ ├── /services/              <span class="comment"># 各模块接口请求</span></span><br><span class="line">│ ├── /utils/                 <span class="comment"># 公用工具</span></span><br><span class="line">└── index.ejs                 </span><br><span class="line">└── index.js                  <span class="comment"># 入口文件</span></span><br><span class="line">└── router.js                 <span class="comment"># 路由文件</span></span><br></pre></td></tr></table></figure><h2 id="component"><a href="#component" class="headerlink" title="component"></a>component</h2><hr><p>UI组件，由开发者提供，负责UI视觉层；所有数据由props提供，不适用任何 <code>Redux</code> 的 API</p><h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><hr><p>容器组件，由 <code>react-redux</code> 自动生成，管理数据及业务逻辑，不负责UI实现；使用 <code>Redux</code> 的 API</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">const UiComponent &#x3D; (&#123;state, dispatch, location, history&#125;) &#x3D;&gt; ();</span><br><span class="line"></span><br><span class="line">const mapStateToProps &#x3D; (state, ownProps) &#x3D;&gt; state;</span><br><span class="line"></span><br><span class="line">const mapDispatchToProps &#x3D; (dispatch, ownProps) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        onAction: () &#x3D;&gt; &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: &#39;&#39;,</span><br><span class="line">                &#123;data&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">export connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)(UiComponent);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 经connect后的组件，可获取到state, dispatch, location, history</span><br></pre></td></tr></table></figure><h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><hr><p>dva最为重要的部分，可当做是对redux、react-redux、redux-saga的封装</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>model的命名空间，全局state的一个属性，即state.namespace</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>对应的是 <code>reducer</code> 的 <code>initialState</code></p><p><strong>额外说明</strong><br>react 的 state 和 redux 的 state 不是一个性质的东西，react 中的 state 是组件内部本身的状态，而 redux 的 state 则是 redux 本身的数据，提供给 react 使用，redux 也可提供给其它框架使用。</p><h3 id="subscription"><a href="#subscription" class="headerlink" title="subscription"></a>subscription</h3><p><em>dom ready后执行</em><br>订阅某些数据源，根据情况 <code>dispatch</code> 某些 <code>action</code></p><h3 id="effects"><a href="#effects" class="headerlink" title="effects"></a>effects</h3><p>对应的是 <code>redux-saga</code>，简化了使用方式<br>处理异步操作，发起异步action，<em>不能直接修改state</em><br>本身为对象，存放的只能是 <code>generator</code> 生成器函数，每个函数携带两个参数 <code>action</code> 和 <code>effects</code>，<br>而 <code>effects</code> 包含 <code>put</code>、<code>call</code>、<code>select</code> 三个字段，其中 <code>put</code> 触发 <code>action</code>，<code>call</code> 调用异步处理逻辑，<code>select</code> 从 <code>state</code> 中获取数据</p><h3 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h3><p>发起同步action<br><em>唯一可以修改state的地方</em><br>本身为对象，存放的每个函数都携带两个参数：<code>state</code> 和 <code>action</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;DVA&quot;&gt;&lt;a href=&quot;#DVA&quot; class=&quot;headerlink&quot; title=&quot;DVA&quot;&gt;&lt;/a&gt;DVA&lt;/h1&gt;&lt;hr&gt;
&lt;h3 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="http://yoursite.com/2019/06/21/docker/"/>
    <id>http://yoursite.com/2019/06/21/docker/</id>
    <published>2019-06-21T07:29:09.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dockerfile-和-docker-compose-的关系"><a href="#dockerfile-和-docker-compose-的关系" class="headerlink" title="dockerfile 和 docker-compose 的关系"></a>dockerfile 和 docker-compose 的关系</h1><p>背景是需要搭建个wordpress。</p><p>Q: 假如你不用 docker ，搭建 wordpress 怎么弄？<br>A: 先找台 server ，假设其 OS 为 Ubuntu ，然后按照文档一步步敲命令，写配置.</p><p>Q: 用 docker 呢？<br>A: 随便找台 server ，不管什么操作系统，只要支持 docker 就行，<br>执行终端命令 <code>docker run ubuntu</code>，docker 会从官方源里拉取最新的 Ubuntu 镜像，<br>可以认为你开了个 Ubuntu 虚拟机，然后一步步安装，跟上面一样。</p><p>BUT，但是这样安装有个显著的缺点，一旦 container (容器) 被删，你做的工作就都没了。<br>当然可以用命令<code>docker commit</code> 来保存成镜像，这样就可以复用了。</p><p>但是镜像一般比较大，而且只分享镜像的话，别人也不知道你这镜像到底包含什么，<br>这些问题都不利于分享和复用。一个直观的解决方案就是，写个脚本把安装过程全部记录下来，<br>这样再次安装的时候，执行脚本就行了。</p><p>而 Dockerfile 就是这样的脚本，它记录了一个镜像的制作过程。有了 <em>Dockerfile</em>, 只要执行<br><code>docker build</code> ，就能制作镜像，而且 <em>Dockerfile</em> 就是文本文件，修改也很方便。</p><p>现在有了 wordpress 的镜像，只需要 docker run 就把 wordpress 启动起来了。</p><p>如果仅仅是 wordpress, 这也就够了。但是很多时候，需要多个镜像合作才能启动一个服务，<br>比如前端要有 nginx ，数据库 mysql , 邮件服务等等，当然你可以把所有这些都弄到一个镜像里去，<br>但这样做就无法复用了。更常见的是, nginx, mysql, smtp 都分别是个镜像，然后这些镜像合作，<br>共同服务一个项目。<em>docker-compose</em> 就是解决这个问题的。你的项目需要哪些镜像，每个镜像怎么<br>配置，要挂载哪些 volume, 等等信息都包含在 docker-compose.yml 里。要启动服务，<br>只需要执行命令 <code>docker-compose up</code> 就行，停止也只需要 <code>docker-compse stop/down</code>。</p><p>简而言之， <em>Dockerfile</em> 记录单个镜像的构建过程，<em>docker-compse.yml</em> 记录一个<br>项目(project, 一般是多个镜像)的构建过程。</p><p>至于结合使用 dockerfile+docker-compose, 是因为 <em>docker-compose.yml</em> 本身没有镜像<br>构建的信息，如果镜像是从 <code>docker registry</code> 拉取下来的，那么 <em>Dockerfile</em> 就不需要；<br>如果镜像是需要 build 的，那就需要提供 <em>Dockerfile</em>。</p><h1 id="Dockerfile、Docker镜像和-Docker容器的关系"><a href="#Dockerfile、Docker镜像和-Docker容器的关系" class="headerlink" title="Dockerfile、Docker镜像和 Docker容器的关系"></a>Dockerfile、Docker镜像和 Docker容器的关系</h1><p><a href="http://blog.csdn.net/zhousenshan/article/details/51501734" target="_blank" rel="noopener">click</a></p><h1 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h1><p><a href="http://blog.csdn.net/mozf881/article/details/55798811" target="_blank" rel="noopener">click</a></p><h1 id="多进程管理工具-Supervisor-Dockerfile"><a href="#多进程管理工具-Supervisor-Dockerfile" class="headerlink" title="多进程管理工具 - Supervisor + Dockerfile"></a>多进程管理工具 - Supervisor + Dockerfile</h1><p><a href="https://www.linuxprobe.com/docker-process-management1.html" target="_blank" rel="noopener">click</a></p><h1 id="linux-docker-dockerfile-supervisor-终端命令回忆录"><a href="#linux-docker-dockerfile-supervisor-终端命令回忆录" class="headerlink" title="linux + docker + dockerfile + supervisor 终端命令回忆录"></a>linux + docker + dockerfile + supervisor 终端命令回忆录</h1><p>查看端口情况<br><code>netstat -ntlp</code></p><p>查看端口映射关系<br><code>iptables -t nat -L -n</code></p><p>端口映射 - linux<br><code>iptables -t nat -A DOCKER -p tcp --dport 8001 -j DNAT --to-destination x.x.x.x:8000</code></p><p>sudo docker run –detach <br>  –hostname gitlab.example.com <br>  –publish 443:443 –publish 88:80 –publish 23:22 <br>  –name gitlab <br>  –restart always <br>  –volume /srv/gitlab/config:/etc/gitlab <br>  –volume /srv/gitlab/logs:/var/log/gitlab <br>  –volume /srv/gitlab/data:/var/opt/gitlab <br>  gitlab/gitlab-ce:latest</p><p>关闭端口映射关系 (需要重启生效)<br><code>iptables -A DOCKER -p tcp --dport 8001 -j DROP</code></p><p>端口映射 - mac<br><code>lsof -i -P | grep docke</code><br><code>sudo vim /etc/pf.anchors/eclipse.tomcat.forwarding</code><br><code>rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 3333 -&gt; x.x.x.x port 3333</code><br><code>sudo pfctl -ef /etc/pf-tomcat.conf</code></p><h1 id="导致docker自启不了可能的原因"><a href="#导致docker自启不了可能的原因" class="headerlink" title="导致docker自启不了可能的原因"></a>导致docker自启不了可能的原因</h1><ol><li>宿主机自启服务的端口与容器自启服务端口有冲突</li></ol><p>查看docker容器IP<br><code>docker inspect auto_testing | grep IPAddress</code></p><p>查看正在运行容器 &amp; 查看所有包括停止的容器<br><code>docker ps</code> &amp; <code>docker ps -a</code></p><p>启动已停止的容器<br><code>docker start auto_testing</code></p><p>进入容器并执行指定命令（Ctrl + P + Q 退出容器保持后台运行）<br><code>docker exec -it auto_testing /bin/bash</code></p><p>查看容器在它生命周期的记录<br><code>docker logs auto_testing</code><br><em>注意事项</em> 当run容器后，启动不了容器，检查下log可发现问题</p><p>基于现有容器提交镜像至本地库<br><code>docker commit -m=&quot;for auto testing&quot; --author=&quot;xxx&quot; auto_testing auto_testing/ubuntu:v1</code></p><p>pull下来的镜像可能某些工具缺失<br><code>apt-get update &amp;&amp; \apt-get install -y vim procps net-tools git</code></p><p>后台启动容器并指定端口映射<br><code>docker run --restart=always --name auto_testing_v1 -d -p 8360:8360 -p 27018:27017 -p 9002:9001 auto_testing/ubuntu:v1 supervisord -n -c /etc/supervisord.conf</code></p><p><code>docker run --restart=always --privileged --name auto_testing \-d -p 8360:8360 -p 27018:27017 -p 9002:9001 \ubuntu/auto_testing:1.0 /bin/bash \-c &quot;while true;do echo hello world; sleep;done&quot;</code></p><p><code>docker run --restart=always --privileged --name nginx-test-1 \-d -p 80:80 nginx /bin/bash \-c &quot;while true;do echo hello world; sleep;done&quot;-v /pengzhiyang/nginx/conf.d:/etc/nginx/conf.d \</code></p><p>安装supervisor<br><code>yum install python-setuptools</code></p><p>生成supervisor配置文件模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">easy_install supervisor</span><br><span class="line">echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><p>使用配置文件启用supervisor<br><code>supervisord -c /etc/supervisord.conf</code></p><p>查看运行进程<br><code>supervisorctl status</code></p><p>停用supervisor<br><code>supervisorctl shutdown</code></p><p>#auto_testing 容器已部署的模块</p><ol><li>系统ubuntu</li><li>git</li><li>node</li><li>mongo<br>安装路径：<code>/projects/mongodb</code></li></ol><p>配置环境变量<br><code>vi /etc/profile</code><br>末行位置新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MONGODB_HOME&#x3D;&#x2F;projects&#x2F;mongodb</span><br><span class="line">export PATH&#x3D;&#x2F;projects&#x2F;mongodb&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p><code>vi /etc/rc.local</code><br>配置开机启动服务(后台运行)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;projects&#x2F;mongodb&#x2F;bin&#x2F;mongod \</span><br><span class="line">--fork --port 27017 \</span><br><span class="line">--dbpath&#x3D;&#x2F;projects&#x2F;mongodb&#x2F;db \</span><br><span class="line">--logpath&#x3D;&#x2F;projects&#x2F;mongodb&#x2F;logs&#x2F;mongodb.log --logappend</span><br></pre></td></tr></table></figure><p>取消占用<br><code>rm -rf /projects/mongodb/db/mongod.lock</code></p><p>查看进程占用<br><code>netstat -ntpl</code></p><p>强制杀掉占用进程<br><code>kill -s 9 [pid]</code></p><ol start="5"><li>supervisor 进程控制管理</li></ol><h2 id="docker里安装ubuntu，ubuntu里再安装docker"><a href="#docker里安装ubuntu，ubuntu里再安装docker" class="headerlink" title="docker里安装ubuntu，ubuntu里再安装docker"></a>docker里安装ubuntu，ubuntu里再安装docker</h2><ol><li><code>docker pull ubuntu</code></li><li><code>docker run -it -d --privileged --name xxx ubuntu</code></li><li><code>docker exec -it xxx /bin/bash</code></li><li><code>apt-get update</code></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common \</span><br><span class="line">    net-tools \</span><br><span class="line">    iptables</span><br></pre></td></tr></table></figure></li><li><code>curl -fsSL get.docker.com -o get-docker.sh</code></li><li><code>sh get-docker.sh --mirror Aliyun</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dockerfile-和-docker-compose-的关系&quot;&gt;&lt;a href=&quot;#dockerfile-和-docker-compose-的关系&quot; class=&quot;headerlink&quot; title=&quot;dockerfile 和 docker-compose 的关
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>node支持ES6语法配置</title>
    <link href="http://yoursite.com/2018/10/15/node_support_es6/"/>
    <id>http://yoursite.com/2018/10/15/node_support_es6/</id>
    <published>2018-10-15T03:31:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>让node支持ES6语法的配置方案</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel-cli&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">&quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;babel-runtime&quot;: &quot;^6.26.0&quot;</span><br></pre></td></tr></table></figure><h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h2><ul><li>根目录添加 babel 配置文件 .babelrc</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;es2015&quot;,</span><br><span class="line">        &quot;stage-0&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;transform-runtime&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="entry-js"><a href="#entry-js" class="headerlink" title="entry.js"></a>entry.js</h2><ul><li>在入口文件里引入</li></ul><p><code>require(&#39;babel-core/register&#39;);</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让node支持ES6语法的配置方案&lt;/p&gt;
&lt;h2 id=&quot;package-json&quot;&gt;&lt;a href=&quot;#package-json&quot; class=&quot;headerlink&quot; title=&quot;package.json&quot;&gt;&lt;/a&gt;package.json&lt;/h2&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="node" scheme="http://yoursite.com/categories/node/"/>
    
    
      <category term="node es6" scheme="http://yoursite.com/tags/node-es6/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录八</title>
    <link href="http://yoursite.com/2016/11/18/learn-from-nodejs/"/>
    <id>http://yoursite.com/2016/11/18/learn-from-nodejs/</id>
    <published>2016-11-18T10:17:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h2><p>基于WebSocket出现的问题，Socket.IO在解决问题的同时保留了其API，也提供了良好的灵活性  </p><h3 id="兼容性高"><a href="#兼容性高" class="headerlink" title="兼容性高"></a>兼容性高</h3><p>Socket.IO的消息传递是<strong>基于传输</strong>的，并非全依靠WebSocket，可在大部分浏览器和设备上运行，包括IE6到IOS  </p><h3 id="可靠事件机制"><a href="#可靠事件机制" class="headerlink" title="可靠事件机制"></a>可靠事件机制</h3><p>提供对<strong>超时</strong>支持，监听 <code>connect</code> 和 <code>disconnect</code> 事件而不是 <code>open</code> 和 <code>close</code> 事件  </p><h3 id="Web通信方式"><a href="#Web通信方式" class="headerlink" title="Web通信方式"></a>Web通信方式</h3><p>典型通信方式经HTTP收发资源，而<strong>实时</strong>Web世界中，都是基于<strong>事件传输</strong>的  </p><p>Socket.IO通过分发 (<code>emit</code>) 和 监听 (<code>listen</code>) 来进行JSON数据收发  </p><p>WebSocket.IO方式  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    ws.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">        socket.on(&#39;message&#39;, function(msg)&#123;</span><br><span class="line">            &#x2F;&#x2F; deal with msg</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>Socket.IO方式  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    io.sockets.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">        socket.on(&#39;message&#39;, function(msg)&#123;</span><br><span class="line">            &#x2F;&#x2F; deal with msg</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间即多路传输，socket.io对同样的资源进行<strong>频道划分</strong>，并将数据传输给对应的回调，且允许监听多个命名空间的 <code>connection</code> 事件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    io.sockets.on(&#39;connection&#39;);</span><br><span class="line">    io.of(&#39;&#x2F;some&#x2F;namespace&#39;).on(&#39;connection&#39;);</span><br><span class="line">    io.of(&#39;&#x2F;some&#x2F;other&#x2F;namespace&#39;).on(&#39;connection&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="实现实时聊天"><a href="#实现实时聊天" class="headerlink" title="实现实时聊天"></a>实现实时聊天</h3><ol><li>引入express和socket.io模块声明为 <code>sio</code></li><li>express创建服务并将返回对象 <code>app</code> 给 <code>sio</code> 监听</li><li>调用监听返回的全局对象 <code>io</code> 的 <code>sockets</code> 属性</li><li>用来监听 <code>connection</code>，回调带socket参数</li><li>该参数在连接后，用来监听客户端分发的 <code>join</code> 用户加入的事件</li><li>监听客户端分发的数据事件 <code>text</code></li><li>在 <code>join</code> 事件回调中，<code>broadcast.emit()</code> 给<strong>所有用户</strong>分发 <code>annoucement</code> 事件</li><li>在客户端调用全局对象的 <code>connect()</code> 方法</li><li>调用返回的对象 <code>socket</code> ，用来监听 <code>connect</code> 事件</li><li>监听后回调中，使用 <code>socket</code> 来分发 <code>emit</code> 事件和给回调的参数</li><li>当客户端有用户加入时，在 <code>connect</code> 回调中分发事件 <code>join</code></li><li>监听服务端分发的 <code>annoucement</code> 事件</li><li>当用户提交消息时，分发 <code>text</code> 事件和给回调的参数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;Socket-IO&quot;&gt;&lt;a href=&quot;#Socket-IO&quot; class=&quot;headerlink&quot; title=&quot;Socket.IO&quot;&gt;&lt;/a&gt;Socket.IO&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="nodejs javascript" scheme="http://yoursite.com/categories/nodejs-javascript/"/>
    
    
      <category term="nodejs express socket.io" scheme="http://yoursite.com/tags/nodejs-express-socket-io/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 需要知道的事</title>
    <link href="http://yoursite.com/2016/11/17/weixin_small_app/"/>
    <id>http://yoursite.com/2016/11/17/weixin_small_app/</id>
    <published>2016-11-17T05:55:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p><h2 id="什么是微信小程序"><a href="#什么是微信小程序" class="headerlink" title="什么是微信小程序"></a>什么是微信小程序</h2><p>微信小程序是一种不需要下载安装即可使用的应用  </p><p>实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用  </p><p>体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题  </p><p>应用将无处不在，随时可用，但又无需安装卸载  </p><h3 id="小程序和公众号内嵌H5有什么区别"><a href="#小程序和公众号内嵌H5有什么区别" class="headerlink" title="小程序和公众号内嵌H5有什么区别"></a>小程序和公众号内嵌H5有什么区别</h3><ol><li><p>一般公众号会在菜单底部提供功能引导入口，引导用户到H5页面，但H5体验与Native App差距还是比较大的，而微信小程序提供丰富框架组件和API接口，在这些组件和接口的帮助下，开发在微信的小程序基本保持与Native App一样的流畅度，极大提高了用户体验  </p></li><li><p>微信小程序可以理解为RN即React Native，H5写的程序然后以Native App方式运行，其原理都是用JS调用底层Native组件  </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。&lt;/p&gt;
&lt;h2 id=&quot;什么是微信小程序&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="weixin H5 js react" scheme="http://yoursite.com/categories/weixin-H5-js-react/"/>
    
    
      <category term="weixin H5 js react" scheme="http://yoursite.com/tags/weixin-H5-js-react/"/>
    
  </entry>
  
  <entry>
    <title>react 回忆录二</title>
    <link href="http://yoursite.com/2016/11/11/learn-from-react/"/>
    <id>http://yoursite.com/2016/11/11/learn-from-react/</id>
    <published>2016-11-11T02:55:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>革命性创新 性能出众 代码逻辑灰常简单的 React</p><h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>本身为一种架构，将Flux与函数式编程结合在一起</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>用户使用方式复杂</li><li><strong>不同身份</strong>用户拥有<em>不同使用方式</em></li><li>多用户间可<strong>协作</strong></li><li>与<em>服务器<em>大量交互，亦或使用</em>WebSocket</em></li><li>View需从<strong>多个来源</strong>获取数据</li><li>某组件的<em>状态</em>需<strong>共享</strong></li><li>某状态需在<em>任何地方</em>都可拿到</li><li>单个组件需改变<strong>全局状态</strong></li><li>一个组件需改变<em>另一个</em>组件状态</li></ol><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>Web App是一个状态机，视图和状态是一一对应的</li><li>所有状态保存至一个对象里面</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>用来保存所有数据的容器，整个App只能有一个，由 <code>createStore(fn)</code> 来生成，接受一个Reducer函数作为参数，即后面所说到的Reducer，一个用来根据Action的不同而生成此刻的State快照的函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;;</span><br><span class="line">const store &#x3D; createStore(fn);</span><br></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>当想从Store里获得<strong>某时间点</strong>的数据，可对Store生成快照，而这种时间点下的数据集合称为<strong>State</strong>  </p><p>而state储存在一棵对象树state tree中，且这棵树只存在于唯一的store中  </p><p>当前时刻的State可由 <code>store.getState()</code> 获得  </p><p>State与View一一对应，即State相同View就相同  </p><p>State本身是<strong>只读</strong>的，而改变它的方法就是触发action  </p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>本身为一个描述已发生事件的对象，接受的属性有<strong>type</strong>(必选 表示Action名称)和其它自定义属性  </p><p>因State的变化需由View来导致，而Action为View发出的<strong>通知</strong>，告诉State应有所变化了  </p><p>Action描述当前所发生的事情，它是改变State的唯一办法，它会运送数据至Store  </p><p>Action是把数据从应用传到store的有效载荷，是store数据的唯一来源，一般经 <code>store.dispatch()</code> 传action到store  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const action &#x3D; &#123;</span><br><span class="line">    type: &#39;ADD_TODO&#39;, &#x2F;&#x2F; 名称</span><br><span class="line">    payload: &#39;Learn Redux&#39; &#x2F;&#x2F; 携带信息</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可封装一个生成Action的函数，只需提供Action的名称即可  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Action Creator</span><br><span class="line">const ADD_TODO &#x3D; &#39;添加 TODO&#39;;</span><br><span class="line">function addTodo(text)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        tyep: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const action &#x3D; addTodo(&#39;Learn Redux&#39;);</span><br></pre></td></tr></table></figure><h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch()"></a>dispatch()</h4><p><code>store.dispatch()</code>  是View发出Action的唯一办法，接受Action对象作为参数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;;</span><br><span class="line">const store &#x3D; createStore(fn);</span><br><span class="line">store.dispatch(addTodo(&#39;Learn redux&#39;));</span><br></pre></td></tr></table></figure><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>当Store收到Action时，Store需给出一个新的State快照，从而View才会变化，整个一个过程称为Reducer，它接受Action和此刻的State快照作为参数，并返回一个新的State  </p><p>即 <code>(previousState, action) =&gt; newState</code>  </p><p>简单来说，就是为了描述action是如何改变state tree的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const defaultState &#x3D; 0;</span><br><span class="line">const reducer &#x3D; (state &#x3D; defaultState, action) &#x3D;&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;ADD&#39;:</span><br><span class="line">            return state + action.payload;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const state &#x3D; reducer(1, &#123;</span><br><span class="line">    type: &#39;ADD&#39;,</span><br><span class="line">    payload: 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的Reducer需手动调用，而当把它作为参数传入 <code>createStore(reducer)</code>，可实现每当 <code>store.dispatch()</code> 发来一个新Action时，自动调用Reducer并得到新State  </p><h5 id="Reducer拆分"><a href="#Reducer拆分" class="headerlink" title="Reducer拆分"></a>Reducer拆分</h5><p>面对所有reducers最终只会生成唯一的state对象，这意味着该state包含所有数据，导致本身体积十分庞大，进而有了对reducers的拆分  </p><p>拆分后，单独的reducer可独立操作state tree中某个state，可控制它们被调用的顺序，传入附加数据，编写可复用的reducer来处理一些通用任务  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const chatReducer &#x3D; (state &#x3D; defaultState, action &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 假设 action &#x3D; &#123;type: &#39;add&#39;, payload: &#39;str&#39;&#125;;</span><br><span class="line">     * 则声明 const &#123; type, payload &#125; &#x3D; action;</span><br><span class="line">     * 调用type返回&#39;add&#39;，调用payload返回&#39;str&#39;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    const &#123; type, payload &#125; &#x3D; action; &#x2F;&#x2F; 解构赋值</span><br><span class="line">    switch(type)&#123;</span><br><span class="line">        case &#39;ADD_CHAT&#39;:</span><br><span class="line">            return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                    &#x2F;&#x2F; Object.assign(&#123;&#125;, &#123;&#125;, ...) 合并多个对象</span><br><span class="line">                    &#x2F;&#x2F; 遇相同属性时 位于后面的属性覆盖前面的</span><br><span class="line">                    chatLog: state.chatLog.concat(payload) &#x2F;&#x2F; str.concat(str) 拼接指定字符串</span><br><span class="line">                &#125;);</span><br><span class="line">        case &#39;CHANGE_STATUS&#39;:</span><br><span class="line">            return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                    statusMessage: payload</span><br><span class="line">                &#125;);</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出上述代码，有两种Action分别改变State的两个属性  </p><ul><li>ADD_CHAT =&gt; chatLog属性</li><li>CHANGE_STATUS =&gt; statusMessage属性</li></ul><p>把上述各个reducer进行拆分  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主reducer</span><br><span class="line">const chatReducer &#x3D; (state &#x3D; defaultState, action &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 子reducer</span><br><span class="line">        chatLog: chatLog(state.chatLog, action),</span><br><span class="line">        statusMessage: statusMessage(state.statusMessage, action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个子reducer分别处理全局state中的一部分，各自的state参数都是不同的，分别对应它管理的那部分state数据  </p><p>再由 <code>combineReducers()</code> 来合并reducer成一个大的Reducer  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#39;redux&#39;;</span><br><span class="line">const chatReducer &#x3D; combineReducers(&#123;</span><br><span class="line">    chatLog,</span><br><span class="line">    statusMessage</span><br><span class="line">&#125;)</span><br><span class="line">export default todoApp;</span><br></pre></td></tr></table></figure><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>当一组actions为数组时，存储着多个Action对象，此时可调用 <code>actions.reduce(reducer, 0)</code> ，reducer作为参数，这样可实现同时处理一个actions数组的Action对象，并得到最终结果  </p><h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe()"></a>subscribe()</h4><p><code>store.subscribe(listener)</code>  Store设置监听函数，可实现一旦store的快照state发生变化后，就会自动执行这个函数  </p><p>用于把组件的render方法亦或setState方法作为listener监听对象，state变化的同时自动渲染View页面  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let unsubscribe &#x3D; store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(store.getState());</span><br><span class="line">&#125;);</span><br><span class="line">unsubscribe(); &#x2F;&#x2F;直接调用能解除监听</span><br></pre></td></tr></table></figure><h2 id="Redux工作流程"><a href="#Redux工作流程" class="headerlink" title="Redux工作流程"></a>Redux工作流程</h2><p><img src="http://img.blog.csdn.net/20151210233944838" alt="结构图1"></p><p><img src="http://img.blog.csdn.net/20151210234529139" alt="结构图2"></p><ol><li>用户与View交互发出Action</li><li><code>store.dispatch(Reducer(state, action))</code> store经 <code>store.dispatch()</code> 向View发送state，而Action和此刻state作为参数传入Reducer，Reducer处理后返回新的state，发送给View</li><li>一旦State有新变化，Store调用监听 <code>store.subscribe(listener)</code> ，侦听器listener可能是 <code>store.getState()</code> 获取此刻新state，亦或通知经组件state有变化渲染View</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;革命性创新 性能出众 代码逻辑灰常简单的 React&lt;/p&gt;
&lt;h2 id=&quot;什么是Redux&quot;&gt;&lt;a href=&quot;#什么是Redux&quot; class=&quot;headerlink&quot; title=&quot;什么是Redux&quot;&gt;&lt;/a&gt;什么是Redux&lt;/h2&gt;&lt;p&gt;本身为一种架构，将Flu
      
    
    </summary>
    
    
      <category term="react redux jsx" scheme="http://yoursite.com/categories/react-redux-jsx/"/>
    
    
      <category term="react redux jsx" scheme="http://yoursite.com/tags/react-redux-jsx/"/>
    
  </entry>
  
  <entry>
    <title>online resume record</title>
    <link href="http://yoursite.com/2016/11/05/prepare-resume-record/"/>
    <id>http://yoursite.com/2016/11/05/prepare-resume-record/</id>
    <published>2016-11-05T02:03:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>在线简历构建过程记录</p><h2 id="Jade"><a href="#Jade" class="headerlink" title="Jade"></a>Jade</h2><p>…占位</p><h3 id="include-amp-amp-extends"><a href="#include-amp-amp-extends" class="headerlink" title="include &amp;&amp; extends"></a>include &amp;&amp; extends</h3><ul><li><code>include</code>  引入页面补充部分，哪个位置缺某部分，包含进来作补充</li><li><code>extends</code>  先给出整体，再替换局部</li></ul><p>include应用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.jade</span><br><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">    include header</span><br><span class="line">    body</span><br><span class="line">        h1 welcome xxx</span><br><span class="line">        p content</span><br><span class="line">    include footer</span><br></pre></td></tr></table></figure><p>extends应用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layout.jade</span><br><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">        block title</span><br><span class="line">            title Default Title</span><br><span class="line">    body</span><br><span class="line">        block content</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.jade</span><br><span class="line">extends layout</span><br><span class="line">block title</span><br><span class="line">    title New Title</span><br><span class="line">block content</span><br><span class="line">    h1 new title</span><br><span class="line">    p new content</span><br></pre></td></tr></table></figure><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>gulp执行指定任务并回调  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    gulp.task(&#39;build&#39;, [&#39;task1&#39;, &#39;task2&#39;], function()&#123;</span><br><span class="line">        &#x2F;&#x2F; 只执行任务build</span><br><span class="line">        &#x2F;&#x2F; 同时会执行task1, task2</span><br><span class="line">        gulp.src(&#39;src&#39;) &#x2F;&#x2F; 将返回对象流</span><br><span class="line">            .pipe(plugin1());</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.task(&#39;task1&#39;, function()&#123;</span><br><span class="line">        gulp.src(&#39;src1&#39;)</span><br><span class="line">            .pipe(plugin1());</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.task(&#39;task2&#39;, [&#39;task1&#39;], function()&#123;</span><br><span class="line">        &#x2F;&#x2F; 可让task1执行完</span><br><span class="line">        &#x2F;&#x2F; 再执行task2</span><br><span class="line">        gulp.src(&#39;src2&#39;)</span><br><span class="line">            .pipe(plugin2());</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>gulp task</code> 命令行执行任务名，直接执行指定任务  </p><p><em>gulp.src()方法输入一个如匹配一个或多个文件的字符串，或者glob数组，然后返回一个可以传递给插件的数据流</em>  </p><p><code>pipe()</code> 把<strong>对象流</strong>对接在插件上，并让插件处理对象  </p><ul><li>Plugins</li></ul><p><code>gulp-load-plugins</code>  该插件自动按需(当需被调用时才加载)加载 <code>paskage.json</code> 中Gulp插件，并把它们附加在一个对象上  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var gulp &#x3D; require(&#39;gulp&#39;),</span><br><span class="line">        gulpLoadPlugins &#x3D; require(&#39;gulp-load-plugins&#39;),</span><br><span class="line">        plugins &#x3D; gulpLoadPlugins();</span><br><span class="line">    gulp.task(&#39;js&#39;, function () &#123;</span><br><span class="line">       return gulp.src(&#39;js&#x2F;*.js&#39;)</span><br><span class="line">          .pipe(plugins.jshint())</span><br><span class="line">          .pipe(plugins.jshint.reporter(&#39;default&#39;))</span><br><span class="line">          .pipe(plugins.uglify())</span><br><span class="line">          .pipe(plugins.concat(&#39;app.js&#39;))</span><br><span class="line">          .pipe(gulp.dest(&#39;build&#39;)) &#x2F;&#x2F; 指定输出目录</span><br><span class="line">          .pipe(gulp.livereload()); &#x2F;&#x2F; 文件被修改自动加载刷新网页</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>Watch</li></ul><p><code>gulp.watch()</code>  监听文件修改状态，在文件被改动时执行一个或多个任务  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var watcher &#x3D; gulp.task(&#39;watch&#39;, function (e) &#123;</span><br><span class="line">       gulp.watch(&#39;xxx.scss&#39;, [&#39;buildSass&#39;]);</span><br><span class="line">       console.log(&#39;Event type: &#39; + e.type); &#x2F;&#x2F; added, changed, or deleted</span><br><span class="line">       console.log(&#39;Event path: &#39; + e.path); &#x2F;&#x2F; The path of the modified file</span><br><span class="line">    &#125;);</span><br><span class="line">    watcher.on(&#39;change&#39;, function()&#123;&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Gulp-amp-amp-Grunt"><a href="#Gulp-amp-amp-Grunt" class="headerlink" title="Gulp &amp;&amp; Grunt"></a>Gulp &amp;&amp; Grunt</h3><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li><p>Gulp和Grunt的工作方式很不一样。Grunt不使用数据流，而是使用文件，对文件执行单个任务然后保存到新的文件中，每个任务都会重复执行所有进程，文件系统频繁的处理任务会导致Grunt的运行速度比Gulp慢  </p></li><li><p>Grunt任务拥有大量的配置，会引用大量你实际上并不需要的对象属性，但是Gulp里同样的任务也许只有几行而已  </p></li><li><p>Grunt比Gulp更加频繁地操作文件系统，所以使用数据流的Gulp总是比Grunt快。对于一个小的LESS文件，gulpfile.js通常需要6ms，而gruntfile.js则需要大概50ms——慢8倍多  </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在线简历构建过程记录&lt;/p&gt;
&lt;h2 id=&quot;Jade&quot;&gt;&lt;a href=&quot;#Jade&quot; class=&quot;headerlink&quot; title=&quot;Jade&quot;&gt;&lt;/a&gt;Jade&lt;/h2&gt;&lt;p&gt;…占位&lt;/p&gt;
&lt;h3 id=&quot;include-amp-amp-extends&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="javascript gulp jade" scheme="http://yoursite.com/categories/javascript-gulp-jade/"/>
    
    
      <category term="javascript gulp jade" scheme="http://yoursite.com/tags/javascript-gulp-jade/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录七</title>
    <link href="http://yoursite.com/2016/11/01/learn-from-nodejs/"/>
    <id>http://yoursite.com/2016/11/01/learn-from-nodejs/</id>
    <published>2016-11-01T06:03:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><ul><li><p>websocket是一个协议，类似于TCP/IP、HTTP协议，但它们需要有socket辅助来提供给外部调用的API，而websocket本身就有一个 <strong>WebSocket API</strong>  </p></li><li><p>使用socket这样的网络协议APIs不会符合原始安全模型，而websocket则不会，它提供给H5应用TCP的方式却不会削弱网络安全且还能同时拥有现代API  </p></li><li><p>websocket相对于http协议，拟补了http不适合<strong>实时通信</strong>的缺陷，websocket以异步双向通信模式，通过传输层协议使其更急有灵活性  </p></li><li><p>websocket协议能够让客户端和远程服务器端通过web建立<strong>全双工通信</strong>，且支持二进制字符串和文本字符串，协议包含打开<strong>握手</strong>之后的基本消息框架  </p></li></ul><h3 id="websocket-API"><a href="#websocket-API" class="headerlink" title="websocket API"></a>websocket API</h3><ul><li><p>websocket的接口，可通过它来建立<strong>全双工通道</strong>来收发消息，当连接远程服务器，只需创建一个websocket实体，即实例化一个实例，并传入类似 “ws://<a href="http://www.xxx.com&quot;" target="_blank" rel="noopener">www.xxx.com&quot;</a> 的URL  </p></li><li><p>客户端和服务端在开始握手的期间，http会升级至websocket，这样建立了连接，其底层都是TCP协议  </p></li><li><p>websocket api 是<strong>纯事件驱动</strong>的，即可使用异步事件监听来连接其整个生命周期的每个阶段  </p></li></ul><p><code>onopen()</code><br>一旦服务器响应websocket连接请求后触发open事件，这意味着协议握手结束，websocket已准备好收发数据，也就是说现在可确定服务端已经处理好了建立连接的请求，同意和你的应用通信了  </p><p><code>onmessage()</code><br>一旦websocket收到数据后触发message事件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    ws.onmessage &#x3D; function(e)&#123;</span><br><span class="line">        if(e.data)&#123;</span><br><span class="line">            console.log(e.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>onerror</code><br>连接失败或其它操作引起错误等都会触发error事件，从而导致连接关闭  </p><p><code>onclose</code><br>连接关闭时触发close事件，之后客户端和服务器就不能再通信了  </p><ul><li><p>建立其全双工连接，服务器发送数据或资源给客户端，它能自动发送状态改变的<strong>数据和通知</strong>，从而我们无须为了状态的更新而去轮询server，只要在客户端进行监听即可  </p></li><li><p>websocket对象的实例有两个方法：<code>send()</code>  <code>close()</code>  </p></li></ul><p><code>send()</code><br>提供给服务端和客户端相互发送消息的方法，但需要在 <code>onopen</code> 连接完全建立了才能使用该方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    ws.onopen &#x3D; function(e)&#123;</span><br><span class="line">        ws.send(str);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>close()</code><br>手动关闭连接，一旦使用该方法，将不能再发送数据  </p><p><code>ws.close(status, &quot;reason&quot;)</code>  可选两参数，状态码和关闭原因  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    ws.close(</span><br><span class="line">        1000,</span><br><span class="line">        &quot;Closing normally!&quot;</span><br><span class="line">    )</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>websocket对象有三个属性：readyState、bufferedAmount、Protocol</li></ul><p><code>ws.readyState</code><br>该属性来表示连接状态，会随着连接状态变化而变化  </p><table><thead><tr><th align="left">属性</th><th align="right">值</th><th align="center">状态</th></tr></thead><tbody><tr><td align="left">WebSocket.CONNECTING</td><td align="right">0</td><td align="center">连接正进行但未建立</td></tr><tr><td align="left">WebSocket.OPEN</td><td align="right">1</td><td align="center">连接已建立可发送消息</td></tr><tr><td align="left">WebSocket.CLOSING</td><td align="right">2</td><td align="center">正关闭握手</td></tr><tr><td align="left">WebSocket.CLOSED</td><td align="right">3</td><td align="center">连接已关闭或不能打开</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    if(ws.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN)&#123;</span><br><span class="line">        &#x2F;&#x2F; 待连接已建立</span><br><span class="line">        ws.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>ws.bufferedAmount</code><br><code>send()</code>发送的数据不会立即传输，而是被浏览器缓存每次应用流出的数据，bufferedAmount可用来检查每次流出的数据大小，而这些数据已进入队列但未被传输  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;echo.websocket.org&quot;),</span><br><span class="line">        maxData &#x3D; 10240;</span><br><span class="line">    ws.onopen &#x3D; function()&#123;</span><br><span class="line">        setInterval(function()&#123;</span><br><span class="line">            if(ws.bufferedAmount &lt; maxData)&#123;</span><br><span class="line">                ws.send()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>ws.protocol</code><br>返回当前使用的websocket协议，由服务器提供  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;websocket&quot;&gt;&lt;a href=&quot;#websocket&quot; class=&quot;headerlink&quot; title=&quot;websocket&quot;&gt;&lt;/a&gt;websocket&lt;/h2&gt;&lt;u
      
    
    </summary>
    
    
      <category term="nodejs javascript" scheme="http://yoursite.com/categories/nodejs-javascript/"/>
    
    
      <category term="nodejs express websocket" scheme="http://yoursite.com/tags/nodejs-express-websocket/"/>
    
  </entry>
  
  <entry>
    <title>react 回忆录一</title>
    <link href="http://yoursite.com/2016/11/01/learn-from-react/"/>
    <id>http://yoursite.com/2016/11/01/learn-from-react/</id>
    <published>2016-11-01T02:55:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>革命性创新 性能出众 代码逻辑灰常简单的 React</p><h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h2><p>React 起源于Facebook的内部项目，项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案</p><h2 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h2><p>引入三大法宝： <code>react.js</code>、<code>react-dom.js</code>、<code>browser.js</code>  </p><p><code>react.js</code> 是 React 的核心库<br><code>react-dom.js</code> 是提供与 DOM 相关的功能<br><code>browser.js</code> 的作用是将 JSX 语法转为 JavaScript 语法  </p><ul><li>JSX<br>允许 HTML 与 JavaScript 的混写，遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ... --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class="line">    var names &#x3D; [&#39;Leon&#39;, &#39;Leo&#39;],</span><br><span class="line">        arr &#x3D; [</span><br><span class="line">            &lt;h1&gt;React is awesome&lt;&#x2F;h1&gt;,</span><br><span class="line">            &lt;h2&gt;good app!&lt;&#x2F;h2&gt;</span><br><span class="line">        ],</span><br><span class="line">        Msg &#x3D; React.createClass(&#123;</span><br><span class="line">            render: function()&#123;</span><br><span class="line">                return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &#x2F;&#x2F; &lt;h1&gt;Hello world!&lt;&#x2F;h1&gt;,</span><br><span class="line">        &#x2F;&#x2F; &lt;div&gt;</span><br><span class="line">        &#x2F;&#x2F;  &#123;</span><br><span class="line">        &#x2F;&#x2F;      names.map(function(name)&#123;</span><br><span class="line">        &#x2F;&#x2F;          return &lt;div&gt;Hello, &#123;name&#125;!&lt;&#x2F;div&gt;</span><br><span class="line">        &#x2F;&#x2F;      &#125;)</span><br><span class="line">        &#x2F;&#x2F;  &#125;</span><br><span class="line">        &#x2F;&#x2F; &lt;&#x2F;div&gt;,</span><br><span class="line">        &#x2F;&#x2F; &lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;,</span><br><span class="line">        &lt;Msg name&#x3D;&quot;Leon&quot;&#x2F;&gt;,</span><br><span class="line">        document.getElementById(&#39;example&#39;)</span><br><span class="line">    );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>分析</p></li><li><p><code>ReactDOM.render(&quot;HTML&quot;, &quot;DOM&quot;)</code>  基本法，将模版转为HTML语言，并插入指定节点  </p></li><li><p><code>&lt;div&gt;{arr}&lt;/div&gt;</code>  变量是一个数组，结果 JSX 会把它的所有成员，添加到模板</p></li><li><p>组件</p></li></ul><p><strong>组件</strong>并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做<strong>虚拟 DOM</strong> （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM</p><ul><li>DOM diff 算法</li></ul><p>DOM的所有变动，都先在<strong>虚拟 DOM</strong> 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <strong>DOM diff</strong> ，它可以极大提高网页的性能表现</p><ul><li><p><code>React.createClass({})</code>  用于生成一个组件类，如 <code>Msg</code>，模板插入 <Msg /> 时，会自动生成 Msg 的一个实例  </p></li><li><p>组件注意事项： </p></li></ul><p>组件类的第一个字母必须大写;<br>只能包含一个顶层标签;<br>组件的属性可以在组件类的 <code>this.props</code> 对象上获取;<br><code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code>  </p><ul><li><p>组件参数</p></li><li><p>组件属性  </p></li></ul><p><code>this.props</code> 表示那些一旦定义，就不再改变的特性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    Msg &#x3D; React.createClass(&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断传入参数是否符合要求</span><br><span class="line">        propTypes: &#123;</span><br><span class="line">            &#x2F;&#x2F; 限制参数为字符串</span><br><span class="line">            title: React.PropTypes.string.isRequired</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 设置属性默认值</span><br><span class="line">        getDefaultProps: function()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                title: &quot;Hello Leon&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        render: function()&#123;</span><br><span class="line">            return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>组件状态</li></ul><p>组件看成是一个<strong>状态机</strong>，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI  </p><p><code>this.state</code> 是会<em>随着用户互动而产生变化</em>的特性  </p><p>所以，该属性一般在应用在表单比较多  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    Slt_btn &#x3D; React.createClass(&#123;</span><br><span class="line">        &#x2F;&#x2F; 定义初始状态(对象)</span><br><span class="line">        getInitialState: function()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                opt: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        clickSlt: function()&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 修改状态值</span><br><span class="line">                 * 每次修改以后</span><br><span class="line">                 * 自动调用 this.render 方法再次渲染组件</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                opt: !this.state.opt</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        render: function()&#123;</span><br><span class="line">            var text &#x3D; this.state.opt ? &quot;select&quot; : &quot;don&#39;t select&quot;;</span><br><span class="line">            return(</span><br><span class="line">                &lt;p onClick&#x3D;&#123;this.clickSlt&#125;&gt;</span><br><span class="line">                    You &#123;text&#125; this. Click to toggle!</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>组件生命周期</li></ul><p>分别有：  </p><ol><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ol><p>三种状态提供五种处理函数：  </p><ol><li><code>componentWillMount()</code>  组件<strong>载入之前</strong>调用</li><li><code>componentDidMount()</code>  组件<strong>载入之后</strong>调用</li><li><code>componentWillUpdate()</code>  组件<strong>更新之前</strong>调用</li><li><code>componentDidUpdate()</code>  组件<strong>更新之后</strong>调用</li><li><code>componentWillUnmount()</code>  组件<strong>卸载之前</strong>调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;革命性创新 性能出众 代码逻辑灰常简单的 React&lt;/p&gt;
&lt;h2 id=&quot;什么是React&quot;&gt;&lt;a href=&quot;#什么是React&quot; class=&quot;headerlink&quot; title=&quot;什么是React&quot;&gt;&lt;/a&gt;什么是React&lt;/h2&gt;&lt;p&gt;React 起源于Fac
      
    
    </summary>
    
    
      <category term="react jsx" scheme="http://yoursite.com/categories/react-jsx/"/>
    
    
      <category term="react jsx" scheme="http://yoursite.com/tags/react-jsx/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录六</title>
    <link href="http://yoursite.com/2016/10/31/learn-from-nodejs/"/>
    <id>http://yoursite.com/2016/10/31/learn-from-nodejs/</id>
    <published>2016-10-31T06:03:00.000Z</published>
    <updated>2020-04-30T06:38:46.781Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>作为node框架express，基于connect构建而成，保持重用中间件的做法，更加便捷构建web应用  </p><h3 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h3><p>模版语言，用来分离逻辑代码和外在内容，使前后台设计时，对页面或逻辑改动时，相互不影响，更加分清前端和后台设计的工作  </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>假设已安装模块 <code>npm install ejs</code> 和 <code>npm install superagent</code>  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- server.js --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var express &#x3D; require(&#39;express&#39;),</span><br><span class="line">        search &#x3D; require(&#39;.&#x2F;search&#39;),</span><br><span class="line">        app &#x3D; express.createServer();</span><br><span class="line">    app</span><br><span class="line">        .set(&#39;view engine&#39;, &#39;ejs&#39;) &#x2F;&#x2F; 指明模版引擎</span><br><span class="line">        .set(&#39;views&#39;, __dirname + &#39;&#x2F;views&#39;) &#x2F;&#x2F; 指明模版根目录</span><br><span class="line">        .set(&#39;view options&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F; 参数值传递每个模版</span><br><span class="line">            layout: false</span><br><span class="line">        &#125;)</span><br><span class="line">        .set(&#39;view cache&#39;, true); &#x2F;&#x2F; 对模版缓存</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置路由处理器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    app.get(&#39;&#x2F;&#39;, function(req, res)&#123;</span><br><span class="line">        &#x2F;&#x2F; 渲染index模版</span><br><span class="line">        &#x2F;&#x2F; 并作为响应返回</span><br><span class="line">        res.render(&#39;index&#39;);</span><br><span class="line">        &#x2F;&#x2F; console.log(app.set(&#39;views&#39;));</span><br><span class="line">    &#125;);</span><br><span class="line">    app.get(&#39;&#x2F;search&#39;, function(req, res, next)&#123;</span><br><span class="line">        search(req.query.q, function(err, baikes)&#123;</span><br><span class="line">            &#x2F;&#x2F; req.query 获取地址栏传递的参数</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                &#x2F;&#x2F; 调用search(qstr, fn)函数</span><br><span class="line">                &#x2F;&#x2F; 经fn实例化的错误中间件</span><br><span class="line">                return next(err);</span><br><span class="line">            &#125;</span><br><span class="line">            res.render(</span><br><span class="line">                &#39;search&#39;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 传递变量到search.ejs视图</span><br><span class="line">                    &#x2F;&#x2F; 这类变量称作本地变量</span><br><span class="line">                    &#x2F;&#x2F; 因只对其传递视图可见</span><br><span class="line">                    results: baikes,</span><br><span class="line">                    search: req.query.q</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置错误处理器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    app.error(function(err, req, res, next)&#123;</span><br><span class="line">        &#x2F;&#x2F; 配置search(qstr, fn)函数</span><br><span class="line">        &#x2F;&#x2F; fn实例化的错误中间件参数</span><br><span class="line">        if(&#39;Bad baidu baike response&#39; &#x3D;&#x3D; err.message)&#123;</span><br><span class="line">            res.render(</span><br><span class="line">                &#39;error&#39;,</span><br><span class="line">                &#123;</span><br><span class="line">                    status: 500</span><br><span class="line">                &#125;,</span><br><span class="line">                function(err, html)&#123;</span><br><span class="line">                    &#x2F;&#x2F; 第三参数</span><br><span class="line">                    &#x2F;&#x2F; 可处理收到的html</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    app.listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>express.createServer</code> 返回HTTP服务器自带配置系统  </p><p>调用对象 <code>app</code> 上的 <code>set()</code> 来修改默认配置项  </p><p>经express框架处理路由，省去了对 <code>req.url</code> 和 <code>req.method</code> 的判断  </p><p>express为response对象提供了 <code>render()</code> 渲染模版方法，渲染过程：  </p><p>| 初始化模版引擎  </p><p>| 读取视图文件并将其传递给模版引擎  </p><p>| 获取解析后的HTML页面并作为响应发送给客户端  </p><ul><li>结合使用模版语言 可选Ejs或jade  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.ejs --&gt;</span><br><span class="line">&lt;h1&gt;Baike Search App&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;Please enter your search term:&lt;&#x2F;p&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;&#x2F;search&quot; method&#x3D;&quot;GET&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">    &lt;button&gt;Search&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p>表单里，提交到 <code>/search</code> ，所带参数有 <code>q=</code> input标签输入的内容，最终以 <code>search?q=xxx</code> 跳转到提交页面，而地址栏参数，可由 <code>req.query.q</code> 获取  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- search.ejs --&gt;</span><br><span class="line">&lt;h1&gt;Baidu Baike Search results for &lt;%&#x3D; search %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;% if (results.length) &#123; %&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;% for (var i &#x3D; 0; i &lt; results.length; i++) &#123; %&gt;</span><br><span class="line">        &lt;li&gt;&lt;%&#x3D; results[i].name %&gt; - &lt;em&gt;&lt;%&#x3D; results[i].value %&gt;&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">    &lt;p&gt;No resultes&lt;&#x2F;p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>ejs模版语言，js代码嵌入<code>&lt;%</code>和<code>%&gt;</code>间，在<code>&lt;%</code>后加入<code>=</code>符号将变量打印出来  </p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>express为node的Request和Response对象提供了一系列扩展来简化开发  </p><ul><li><p><code>req.header(&#39;host&#39;)</code>  直接获取头信息</p></li><li><p><code>req.accepts(&#39;html&#39;)</code>  判断Accept头信息，返回布尔值</p></li><li><p><code>req.is(&#39;text/html&#39;)</code>  判断 <code>Content-Type</code> 头信息</p></li><li><p><code>res.header(&#39;content-type&#39;)</code>  判断指定值是否已在res上设置</p></li><li><p><code>res.send(500)</code>  直接发送状态码</p></li><li><p><code>res.send(&#39;&lt;p&gt;html&lt;/p&gt;&#39;)</code>  直接发送HTML</p></li><li><p><code>res.send({ obj: val })</code>  序列化对象为JSON对象，并设置 <code>Content-Type</code> 头信息</p></li><li><p><code>res.send([1, 2])</code>  序列化数组为JSON对象，并设置 <code>Content-Type</code> 头信息</p></li><li><p><code>res.json(5)</code>  显示地将内容转成JSON对象</p></li><li><p><code>res.redirect(&#39;/some/other/url&#39;)</code>  等价于发送状态码302及Location头信息  </p></li><li><p><code>res.sendfile(&#39;image.jpg&#39;)</code>  ；类似于<code>static</code>，不同于它用于单个文件  </p></li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><code>app.get(&#39;/&#39;, callback)</code></p><ul><li>自定义参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    app.get(&#39;&#x2F;user&#x2F;:name&#39;, function(req, res, next)&#123;</span><br><span class="line">        return req.params.name &#x3D;&#x3D; &#39;leon&#39;; &#x2F;&#x2F; true</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">name变量会注入 &#96;req.params&#96; 请求参数对象上，匹配url如 &#96;&#x2F;user&#x2F;leon&#96;，而不会匹配到 &#96;&#x2F;user&#x2F;&#96;  </span><br><span class="line"></span><br><span class="line">&#96;app.get(&#39;&#x2F;user&#x2F;:name?&#39;)&#96; 当name变量后添加&quot;?&quot;时，将可以匹配到如 &#96;&#x2F;user&#96; 和 &#96;&#x2F;user&#x2F;leon&#96;  </span><br><span class="line"></span><br><span class="line">&#96;app.get(&#x2F;^\&#x2F;user&#x2F;([a-z\d\-]*)&#x2F;)&#96; 可使用正则匹配，将匹配字母、数字及中划线  </span><br><span class="line"></span><br><span class="line">- 强制匹配其它路由</span><br><span class="line">当一个路由匹配到并得到处理后，同时可以强制继续匹配其它路由</span><br></pre></td></tr></table></figure><script>    app.get('/user/:name', function(req, res, next){        if('leon' != req.params.name[0]) return next();    });</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 中间件</span><br><span class="line">与connect一样地使用中间件，如 &#96;express.static(__dirname)&#96; &#96;express.session()&#96;  </span><br><span class="line"></span><br><span class="line">同时，express允许在*特定匹配到的路由*下才能使用的中间件</span><br></pre></td></tr></table></figure><script>    function secure(req, res, next){        if(!req.session.logged_in){            return res.send(403); //未授权            // 跳过路由的其它中间件            // 直接到下一个路由做处理            // return next('route');         }    }    app.get(        '/finacials',        secure,        function(){}    )</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## express的加载方式</span><br><span class="line">选择一种代码组织策略，保证每个模块都是独立的，则就得确定好各模块的加载方式  </span><br><span class="line"></span><br><span class="line">- 第一种加载方式</span><br><span class="line">良好的代码组织方式应只维护一个 &#96;server.js&#96; 文件，而该文件包含有路由表，且每一部分路由处理器都通过模块化的方式引入  </span><br><span class="line"></span><br><span class="line">**server.js**</span><br></pre></td></tr></table></figure><script>    var express = require('express'),        pages = require('./pages'),        app = express.createServer();    app.get('/pages', pages.home);    app.get('/pages/list', pages.list);</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**pages.js**</span><br></pre></td></tr></table></figure><script>    exports.home = function(req, res, next){}    exports.list = function(req, res, next){}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而第一种加载方式，会*出现的问题*是，每个模块引入时，都是指向同一个实例对象 &#96;exports&#96; ，也就是说 &#96;require(&#39;.&#x2F;pages&#39;)&#96; 该模块只能使用一次，因require只会加载一次该模块，不管后面有多少次使用了 &#96;require(&#39;.&#x2F;pages&#39;)&#96;    </span><br><span class="line"></span><br><span class="line">- 第二种加载方式</span><br><span class="line">可以看出，第一种加载方式模块间的**耦合度高**，而第二种加载方式通过一种解耦方式**app挂载**来降低模块间耦合度  </span><br><span class="line"></span><br><span class="line">**server.js**</span><br></pre></td></tr></table></figure><script>    // ...    app.use(require('./pages'));</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**pages.js**</span><br></pre></td></tr></table></figure><script>    var app = module.exports = express.createServer();    app.get('/', function(req, res, next){});    app.get('/list', function(req, res, next){});</script><pre><code>把每个模块单独作为中间件让其它模块使用，这样模块本身就是完全独立的依赖、中间件、配置，等等  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;p&gt;作为node框
      
    
    </summary>
    
    
      <category term="node javascript" scheme="http://yoursite.com/categories/node-javascript/"/>
    
    
      <category term="node nodejs express" scheme="http://yoursite.com/tags/node-nodejs-express/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录五</title>
    <link href="http://yoursite.com/2016/10/28/learn-from-nodejs/"/>
    <id>http://yoursite.com/2016/10/28/learn-from-nodejs/</id>
    <published>2016-10-28T08:00:00.000Z</published>
    <updated>2020-04-30T06:38:46.781Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h2><p>一个基于HTTP服务器的工具集，提供一种新的组织代码方式来与请求、响应对象进行交互，这种方式被称作中间件  </p><h3 id="static中间件"><a href="#static中间件" class="headerlink" title="static中间件"></a>static中间件</h3><ul><li>挂载<br>允许将任意url匹配到文件系统中任意目录  </li></ul><p>假设让 <code>/my-images</code> 这样的url和目录名为 <code>/images</code> 对应起来  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var connect &#x3D; require(&#39;connect&#39;),</span><br><span class="line">        server &#x3D; connect.createServer();</span><br><span class="line">    server.use(</span><br><span class="line">        &#39;&#x2F;my-images&#39;,</span><br><span class="line">        connect.static(&#39;&#x2F;images&#39;)</span><br><span class="line">    );</span><br><span class="line">    server.listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>maxAge<br>作为static的选项，实现限定资源在客户端的缓存时间  </li></ul><p>假设，客户端所有js合并至一个文件，在其文件名加上修订号，此时，设置选项maxAge可实现永缓存起来  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    server.use(</span><br><span class="line">        &#39;&#x2F;js&#39;,</span><br><span class="line">        connect.static(</span><br><span class="line">            &#39;&#x2F;path&#x2F;to&#x2F;bundles&#39;,</span><br><span class="line">            &#123; maxAge: 100000000&#125;</span><br><span class="line">        );</span><br><span class="line">    );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="query中间件"><a href="#query中间件" class="headerlink" title="query中间件"></a>query中间件</h3><p>假设，客户端发送查询请求，url为 <code>/blog-posts?page=5</code> ，访问该url时，node会以字符串的形式将url存储至req.url中  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    server.use(connect.query);</span><br><span class="line">    server.use(function(req)&#123;</span><br><span class="line">        return req.url &#x3D;&#x3D; &quot;&#x2F;blog-posts?page&#x3D;5&quot;; &#x2F;&#x2F; true</span><br><span class="line">        return req.query.page &#x3D;&#x3D; &quot;5&quot;; &#x2F;&#x2F; true</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="logger中间件"><a href="#logger中间件" class="headerlink" title="logger中间件"></a>logger中间件</h3><p>用于对web应用诊断的工具，它将请求和响应信息打印在终端  </p><p>提供了四种日记格式：default、dev、short、tiny  </p><ul><li>connect.logger(‘dev’)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    server.createServer(</span><br><span class="line">        connect.logger(&#39;dev&#39;),</span><br><span class="line">        function(req, res)&#123;</span><br><span class="line">            res.writeHead(200);</span><br><span class="line">            res.end(&#39;Hello world&#39;);</span><br><span class="line">        &#125;</span><br><span class="line">    ).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>等价于初始化connect服务器时调用use两次  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    server.use(connect.logger(&#39;dev&#39;));</span><br><span class="line">    server.use(function(req, res, next)&#123;</span><br><span class="line">        res.writeHead(200);</span><br><span class="line">        res.end(&#39;Fast!&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>终端输出  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F; 200 0ms</span><br><span class="line">GET &#x2F;favicon.ico 200 2ms</span><br></pre></td></tr></table></figure><ul><li>自定义格式</li></ul><p>记录<strong>请求</strong>方法和IP  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    server.use(</span><br><span class="line">        connect.logger(</span><br><span class="line">            &#39;:method :remote-addr&#39;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>记录<strong>响应</strong>的content-length和content-type信息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    server.use(</span><br><span class="line">        connect.logger(</span><br><span class="line">            &#39;type is :res[content-type], &#39; +</span><br><span class="line">            &#39;length is :res[content-length] &#39; +</span><br><span class="line">            &#39;and it took :response-time ms.&#39;</span><br><span class="line">        )</span><br><span class="line">    );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="bodyparser中间件"><a href="#bodyparser中间件" class="headerlink" title="bodyparser中间件"></a>bodyparser中间件</h3><p>用来解析<strong>客户端请求body中的内容</strong>的中间件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#x2F;&quot; method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;doc&quot;&gt;</span><br><span class="line">        &lt;button&gt;Send file!&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    &#x2F;&#x2F; 简写使用connect</span><br><span class="line">    &#x2F;&#x2F; 以下代码同时实现</span><br><span class="line">    &#x2F;&#x2F; 对connect.createServer()的使用</span><br><span class="line">    &#x2F;&#x2F; 和执行了4次的connect.createServer().use()</span><br><span class="line">    server &#x3D; connect(</span><br><span class="line">        connect.static(__dirname), &#x2F;&#x2F; 挂载当前执行js的目录</span><br><span class="line">        connect.bodyParser(), &#x2F;&#x2F; 使用解析中间件</span><br><span class="line">        connect.logger(&#39;dev&#39;),</span><br><span class="line">        function(req, res, next)&#123;</span><br><span class="line">            if(&#39;POST&#39; &#x3D;&#x3D; req.method)&#123;</span><br><span class="line">             &#x2F;&#x2F; 返回关联数组对象</span><br><span class="line">             &#x2F;&#x2F; 包含键为表单name值doc</span><br><span class="line">             &#x2F;&#x2F; 键doc值为上传文件的所有信息</span><br><span class="line">             console.log(req.files);</span><br><span class="line"></span><br><span class="line">             &#x2F;&#x2F; 返回对应表单name值为doc</span><br><span class="line">             &#x2F;&#x2F; 即上传文件的所有信息</span><br><span class="line">             console.log(req.files.doc);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">             next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="cookieParser中间件"><a href="#cookieParser中间件" class="headerlink" title="cookieParser中间件"></a>cookieParser中间件</h3><p>便捷获取cookie数据，解析Cookies头可经  <code>req.cookies</code> 得到cookies  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Cookie: info1&#x3D;val1; info2&#x3D;val2</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    server.use(connect.cookieParser());</span><br><span class="line">    server.use(function(req, res, next)&#123;</span><br><span class="line">        &#x2F;&#x2F; req.cookies 得到存储cookie的对象</span><br><span class="line">        return req.cookies.info1 &#x3D;&#x3D; &#39;val1&#39;; &#x2F;&#x2F; true</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="session中间件"><a href="#session中间件" class="headerlink" title="session中间件"></a>session中间件</h3><p>会话中间件，多个请求间共享<em>用户会话</em>，类似于用户登录会有某种形式的会话系统，通过设置cookie来保存用户信息  </p><p><code>session(option)</code><br>接受参数option:  </p><p>| 1. key: Cookies名，默认值为connect.sid<br>| 2. store: session存储实例<br>| 3. secret: session的cookie加密<br>| 4. cookie: session的cookie配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var connect &#x3D; require(&#39;connect&#39;),</span><br><span class="line">        users &#x3D; require(&#39;.&#x2F;users&#39;);</span><br><span class="line">    var server &#x3D; connect(</span><br><span class="line">        connect.logger(&#39;dev&#39;),</span><br><span class="line">        connect.bodyParser(),</span><br><span class="line">        &#x2F;&#x2F; 需要使用cookieParser中间件</span><br><span class="line">        &#x2F;&#x2F; 并且需放在session中间件前面</span><br><span class="line">        &#x2F;&#x2F; session的数据经加密后会保存到cookies中</span><br><span class="line">        connect.cookieParser(),</span><br><span class="line">        &#x2F;&#x2F; session默认存储方式存储到内存</span><br><span class="line">        &#x2F;&#x2F; 服务器关闭即进程关闭</span><br><span class="line">        &#x2F;&#x2F; session会丢失</span><br><span class="line">        connect.session(&#123;</span><br><span class="line">            secret: &#39;my app secret&#39;</span><br><span class="line">        &#125;),</span><br><span class="line">        function(req, res, next)&#123;</span><br><span class="line">            &#x2F;&#x2F; 登录后显示的内容</span><br><span class="line">            if(&#39;&#x2F;&#39; &#x3D;&#x3D; req.url &amp;&amp; req.session.logged_in)&#123;</span><br><span class="line">                &#x2F;&#x2F; req.session.logged_in</span><br><span class="line">                &#x2F;&#x2F; 判断登陆与否</span><br><span class="line">                res.writeHead(200, &#123;</span><br><span class="line">                    &quot;Content-Type&quot;: &quot;text&#x2F;html&quot;</span><br><span class="line">                &#125;);</span><br><span class="line">                res.end(</span><br><span class="line">                    &#39;Welcome back, &lt;b&gt;&#39; + req.session.name + &#39;&lt;&#x2F;b&gt;.&#39; +</span><br><span class="line">                    &#39;&lt;a href&#x3D;&quot;&#x2F;logout&quot;&gt;Logout&lt;&#x2F;a&gt;&#39;</span><br><span class="line">                );</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        function(req, res, next)&#123;</span><br><span class="line">            &#x2F;&#x2F; 登录页面内容</span><br><span class="line">            if(&#39;&#x2F;&#39; &#x3D;&#x3D; req.url &amp;&amp; &#39;GET&#39; &#x3D;&#x3D; req.method)&#123;</span><br><span class="line">                res.writeHead(200, &#123;</span><br><span class="line">                    &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">                &#125;);</span><br><span class="line">                res.end([</span><br><span class="line">                    &#39;&lt;form action&#x3D;&quot;&#x2F;login&quot; method&#x3D;&quot;POST&quot;&gt;&#39;,</span><br><span class="line">                    &#39;&lt;fieldset&gt;&#39;,</span><br><span class="line">                    &#39;&lt;lengend&gt;Please log in&lt;&#x2F;lengend&gt;&#39;,</span><br><span class="line">                    &#39;&lt;p&gt;User: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;user&quot; &#x2F;&gt;&lt;&#x2F;p&gt;&#39;,</span><br><span class="line">                    &#39;&lt;p&gt;Password: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;password&quot; &#x2F;&gt;&lt;&#x2F;p&gt;&#39;,</span><br><span class="line">                    &#39;&lt;button&gt;Submit&lt;&#x2F;button&gt;&#39;,</span><br><span class="line">                    &#39;&lt;&#x2F;fieldset&gt;&#39;,</span><br><span class="line">                    &#39;&lt;&#x2F;form&gt;&#39;</span><br><span class="line">                ].join(&#39;&#39;));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        function(req, res, next)&#123;</span><br><span class="line">            if(&#39;&#x2F;login&#39; &#x3D;&#x3D; req.url &amp;&amp; &#39;POST&#39; &#x3D;&#x3D; req.method)&#123;</span><br><span class="line">                res.writeHead(200);</span><br><span class="line">                if(!users[req.body.user] || req.body.password !&#x3D; users[req.body.user].password)&#123;</span><br><span class="line">                    res.end(&#39;Bad username&#x2F;password&#39;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    req.session.logged_in &#x3D; true;</span><br><span class="line">                    req.session.name &#x3D; users[req.body.user].name;</span><br><span class="line">                    res.end(&#39;Authenticated!&#39;);</span><br><span class="line">                    console.log(JSON.stringify(req.session));</span><br><span class="line">                    console.log(JSON.stringify(req.cookies));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        function(req, res, next)&#123;</span><br><span class="line">            if(&#39;&#x2F;logout&#39; &#x3D;&#x3D; req.url)&#123;</span><br><span class="line">                req.session.logged_in &#x3D; false;</span><br><span class="line">                res.writeHead(200);</span><br><span class="line">                res.end(&#39;Logged out!&#39;);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                next();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    server.listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="basicAuth中间件"><a href="#basicAuth中间件" class="headerlink" title="basicAuth中间件"></a>basicAuth中间件</h3><p>向用户提供基本的身份验证  </p><p><code>connect.basicAuth(function(user,pass,fn))</code><br>提供user和pass直接指向用户输入的帐号和密码，fn回调来返回验证成功与否<br>当没有回调fn，将是同步验证，反之有fn回调则为异步验证  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    connect(</span><br><span class="line">        connect.basicAuth(function(user, pass, fn)&#123;</span><br><span class="line">            &#x2F;&#x2F; 实现客户端基本身份异步验证</span><br><span class="line">            process.stdout.write(&#39;Allow user \033[96m&#39; +</span><br><span class="line">                user +</span><br><span class="line">                &#39;\033[39m &#39; +</span><br><span class="line">                &#39;with pass \033[90m&#39; +</span><br><span class="line">                pass +</span><br><span class="line">                &#39;\03339m ? [y&#x2F;n]: &#39;);</span><br><span class="line">            process.stdin.once(&#39;data&#39;, function(data)&#123;</span><br><span class="line">                &#x2F;&#x2F; .once 每个请求获取一次数据</span><br><span class="line">                if(data[0] &#x3D;&#x3D; &#39;y&#39;)&#123;</span><br><span class="line">                    fn(null, &#123;</span><br><span class="line">                        username: user &#x2F;&#x2F; 用来生成req.remoteUser对象</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    fn(new Error(&#39;Unauthorized&#39;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;),</span><br><span class="line">        function(req, res)&#123;</span><br><span class="line">            res.writeHead(200);</span><br><span class="line">            res.end(&#39;Welcome to the protected area.&#39; +</span><br><span class="line">                &#x2F;&#x2F;req.remoteUser返回&#123; username: &#39;xxx&#39;&#125;</span><br><span class="line">                req.remoteUser.username);</span><br><span class="line">        &#125;</span><br><span class="line">    ).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;Connect&quot;&gt;&lt;a href=&quot;#Connect&quot; class=&quot;headerlink&quot; title=&quot;Connect&quot;&gt;&lt;/a&gt;Connect&lt;/h2&gt;&lt;p&gt;一个基于HTT
      
    
    </summary>
    
    
      <category term="node javascript" scheme="http://yoursite.com/categories/node-javascript/"/>
    
    
      <category term="node nodejs" scheme="http://yoursite.com/tags/node-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录四</title>
    <link href="http://yoursite.com/2016/10/23/learn-from-nodejs/"/>
    <id>http://yoursite.com/2016/10/23/learn-from-nodejs/</id>
    <published>2016-10-23T14:42:00.000Z</published>
    <updated>2020-04-30T06:38:46.781Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs<br><img src="http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%ad%a6%e4%b9%a0-11.jpg" alt="HTTP&amp;TCP&amp;IP"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>当在传输数据时，可以单单只是用TCP/IP协议，但无法看到传输的数据，这样这些数据就没什么意义了，一旦有了应用层协议，就能识别数据内容，使其变得有意义，而应用层协议有HTTP、FTP、TELNET，等等  </p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP传输控制协议，HTTP、SMTP、SSH等协议都是基于此协议，它能将数据从一台计算机传输至另一台机器，且保持数据一致性和顺序  </p><p>各种数据库及与数据库通信使用的都是TCP套接字  </p><h3 id="TCP特性"><a href="#TCP特性" class="headerlink" title="TCP特性"></a>TCP特性</h3><p>首要特性是面向连接的  </p><p>因各种的网络应用使用的都是TCP/IP协议，但基于数据包传输的IP，其数据包是独立传输且无序送达  </p><p>当TCP/IP和服务器建立连接时，为了让数据包送达有序，因发送的IP数据包包含了标识该连接及数据流顺序的信息  </p><p>用node写的服务器，只需考虑其连接及往套接字写数据即可，接收方会按序接收信息  </p><h2 id="Telnet"><a href="#Telnet" class="headerlink" title="Telnet"></a>Telnet</h2><p>一种TCP协议上层的协议</p><h3 id="用作访问node服务器的客户端"><a href="#用作访问node服务器的客户端" class="headerlink" title="用作访问node服务器的客户端"></a>用作访问node服务器的客户端</h3><p>Telnet用来访问node写的服务器  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; # server.js</span><br><span class="line">    require(&#39;net&#39;).createServer(function(conn)&#123;</span><br><span class="line">        &#x2F;&#x2F; 每次有新连接建立</span><br><span class="line">        &#x2F;&#x2F; 都会执行一次回调</span><br><span class="line">        console.log(&#39;new connection&#39;);</span><br><span class="line">        &#x2F;&#x2F; createServer的回调接收的一个参数</span><br><span class="line">        &#x2F;&#x2F; conn即net.Stream流对象可读也可写(类似process.stdout.write)</span><br><span class="line">        conn.write(</span><br><span class="line">            &#39;welcome to node&#39;</span><br><span class="line">        );</span><br><span class="line">        conn.on(&#39;data&#39;, function(data)&#123;</span><br><span class="line">            &#x2F;&#x2F; 监视客户端输入数据的变化</span><br><span class="line">        &#125;);</span><br><span class="line">        conn.on(&#39;close&#39;, function()&#123;</span><br><span class="line">            &#x2F;&#x2F; 监视客户端状态(关闭)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>命令终端1输入<code>node server.js</code>  启动服务器<br>命令终端2输入<code>telnet 127.0.0.1 8080</code>  终端二将收到 <em>welcome to node</em><br>命令终端1将收到信息  <em>new connection</em>  </p><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><p>超文本传输协议，是构建在请求与响应上  </p><p>而在node中，http.ServerRequest及http.ServerResponse来实现  </p><h3 id="server-amp-client"><a href="#server-amp-client" class="headerlink" title="server &amp; client"></a>server &amp; client</h3><p>在http模块中，提供http.server()和http.request()两静态方法，分别实例化  </p><h2 id="http-server"><a href="#http-server" class="headerlink" title="http.server()"></a>http.server()</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    require(&#39;http&#39;)</span><br><span class="line">        .server()</span><br><span class="line">        .on(&#39;request&#39;, function(req,res)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;).listen(80);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>等价于  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    require(&#39;http&#39;)</span><br><span class="line">        .createServer(function(req, res)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;).listen(80);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="请求过程"><a href="#请求过程" class="headerlink" title="请求过程"></a>请求过程</h3><p>访问网站时，用户代理即客户端浏览器将会创建一个请求，该请求会经TCP发送给Web服务器，接着服务器做出响应  </p><h4 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h4><ul><li>请求分为请求头(req.headers)和请求体(无)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    require(&#39;http&#39;).createServer(function(req, res)&#123;&#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>回调函数中的两参数，req和res，分别是http.ServerRuest和http.ServerResponse的实例  </p><ul><li>req为request客户端请求，提供了3个事件  </li></ul><p><code>data</code>  请求体数据到达该事件触发，事件提供一个参数chunk，分块处理数据<br><code>end</code>  请求体数据完成传输该事件触发，表示此后将不会有数据到来<br><code>close</code>  请求结束该事件触发  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    req.on(&#39;data&#39;, function(chunk)&#123;</span><br><span class="line">        &#x2F;&#x2F; 监视请求数据变化</span><br><span class="line">        &#x2F;&#x2F; 数据已数据块分块存储</span><br><span class="line">        &#x2F;&#x2F; 并分块发送</span><br><span class="line">        body +&#x3D; chunk;</span><br><span class="line">    &#125;);</span><br><span class="line">    req.on(&#39;end&#39;, function()&#123;</span><br><span class="line">        &#x2F;&#x2F; end事件被触发</span><br><span class="line">        &#x2F;&#x2F; 即数据已接收完全</span><br><span class="line">        &#x2F;&#x2F; 接着向服务器发送数据</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; querystring.parse(str)  解析字符串为对象</span><br><span class="line">        res.end(&#39;&lt;p&gt;your name is &lt;b&gt;&#39; + qs.parse(body).name + &#39;&lt;&#x2F;b&gt;&lt;&#x2F;p&gt;&#39;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>res为response服务器响应，有三个重要成员  </li></ul><p><em>响应头</em>  <code>response.writeHead(状态码, {响应头每个属性})</code>  </p><p><em>响应内容</em>  <code>response.write(data, [encoding])</code>  <code>data</code>为一个buffer(单字节)或字符串，当为字符串需指明其编码方式<code>encoding</code>默认utf-8，在<code>response.end</code>调用前，<code>reponse.write</code>可被多次调用  </p><p><em>结束请求</em>  通知客户端所有发送已完成，被调用一次，不调用的话客户端永处于等待状态  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.write(&#39;响应内容&#39;)</span><br><span class="line">    res.end(&#39;结束响应&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="头信息"><a href="#头信息" class="headerlink" title="头信息"></a>头信息</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    require(&#39;http&#39;).createServer(function(req, res)&#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#x2F;&#x2F; 指明头信息</span><br><span class="line">            &#x2F;&#x2F; 文档类型默认text&#x2F;plain</span><br><span class="line">            &#39;Content-Type&#39;: &#39;text&#x2F;html&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        &#x2F;&#x2F; 由end写入数据时 node会结束响应</span><br><span class="line">        res.end(&#39;Hello &lt;b&gt;World&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">    &#125;).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="块数据"><a href="#块数据" class="headerlink" title="块数据"></a>块数据</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    res.write(&#39;Hello &#39;);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">        res.end(&#39;&lt;b&gt;World&lt;&#x2F;b&gt;&#39;);</span><br><span class="line">    &#125;, 500);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>先写入<em>Hello</em>，再延迟500毫秒写入World并结束响应  </p><p>node允许以数据块形式往响应写数据，且也允许以数据块读文件 –&gt; <code>ReadStream</code>  </p><ul><li>高效内存分配</li><li>数据一旦就绪立即可写入</li></ul><h3 id="ReadStream"><a href="#ReadStream" class="headerlink" title="ReadStream"></a>ReadStream</h3><p>当对于大文件如图片分块传输，会使用对文件创建流对象<code>createReadStream</code>  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    require(&#39;http&#39;).createServer(function(req, res)&#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;image&#x2F;png&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        var stream &#x3D; require(&#39;fs&#39;).createReadStream(&#39;xxx.png&#39;);</span><br><span class="line">        stream.on(&#39;data&#39;, function(data)&#123;</span><br><span class="line">            &#x2F;&#x2F; 对接口</span><br><span class="line">            res.write(data);</span><br><span class="line">        &#125;);</span><br><span class="line">        stream.on(&#39;end&#39;, function()&#123;</span><br><span class="line">            &#x2F;&#x2F; 对接口</span><br><span class="line">            res.end();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>其中，其实是在实现<strong>流的对接</strong>  (<code>.pipe()</code>)  ，即流(Stream)文件系统接上了另一流(http.ServerResponse对象)，所以，上述代码等价于  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    require(&#39;http&#39;).createServer(function(req, res)&#123;</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &#39;Content-Type&#39;: &#39;image&#x2F;png&#39;</span><br><span class="line">        &#125;);</span><br><span class="line">        require(&#39;fs&#39;).createReadStream(&#39;xxx.png&#39;).pipe(res);</span><br><span class="line">    &#125;).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="http-request"><a href="#http-request" class="headerlink" title="http.request()"></a>http.request()</h2><p><code>http.request(option, callback)</code>  作为客户端想http服务器发起请求，返回一个<code>http.ClientRequest</code>  的实例  </p><ul><li><p>参数一option为关联数组对象，表示请求参数<br>| host: 请求网站域名或IP<br>| port: 网站端口 默认80<br>| method: 请求方法 默认GET<br>| path: 请求相对根的路径 默认”/“  一般由<code>querystring</code>模块解析字符串路径为url格式编码<br>| headers: 关联数组对象 请求头内容</p></li><li><p>参数二callback请求回调函数<br>callback回调传递的参数为<code>http.ClientResponse</code>的实例</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; 返回http.ClientRequest的实例</span><br><span class="line">    http.request(&#123;</span><br><span class="line">        host: &#39;127.0.0.1&#39;,</span><br><span class="line">        port: 8080,</span><br><span class="line">        url: &#39;&#x2F;&#39;,</span><br><span class="line">        method: &#39;GET&#39;</span><br><span class="line">    &#125;, function(res)&#123;</span><br><span class="line">        &#x2F;&#x2F; http.ClientResponse的实例</span><br><span class="line">        var body &#x3D; &#39;&#39;;</span><br><span class="line">        res.setEncoding(&#39;utf8&#39;);</span><br><span class="line">        res.on(&#39;data&#39;, function(chunk)&#123;</span><br><span class="line">            &#x2F;&#x2F; 监听响应数据的变化</span><br><span class="line">            &#x2F;&#x2F; 以数据块形式</span><br><span class="line">            &#x2F;&#x2F; 存储至body并保存为字符串</span><br><span class="line">            body +&#x3D; chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        res.on(&#39;end&#39;, function()&#123;</span><br><span class="line">            console.log(&#39;\n We got: \033[96m&#39; + body + &#39;\033[39m\n&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;).end(); &#x2F;&#x2F; 结束响应</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="http-get"><a href="#http-get" class="headerlink" title="http.get()"></a>http.get()</h3><p>类似与<code>http.request()</code>，提供一样的功能，但用法更简洁  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    http.get(&#123;</span><br><span class="line">        &#x2F;&#x2F; 更加明确是GET请求</span><br><span class="line">        host: &#39;127.0.0.1&#39;,</span><br><span class="line">        port: 8080,</span><br><span class="line">        url: &#39;&#x2F;&#39;,</span><br><span class="line">        method: &#39;GET&#39;</span><br><span class="line">    &#125;, function(res)&#123;</span><br><span class="line">        var body &#x3D; &#39;&#39;;</span><br><span class="line">        res.setEncoding(&#39;utf8&#39;);</span><br><span class="line">        res.on(&#39;data&#39;, function(chunk)&#123;</span><br><span class="line">            body +&#x3D; chunk;</span><br><span class="line">        &#125;);</span><br><span class="line">        res.on(&#39;end&#39;, function()&#123;</span><br><span class="line">            console.log(&#39;\n We got: \033[96m&#39; + body + &#39;\033[39m\n&#39;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;); &#x2F;&#x2F; 使用.get() 此处省略了.end()</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h2 id="superagent"><a href="#superagent" class="headerlink" title="superagent"></a>superagent</h2><p>类似于<code>http.request()</code>，一个更加便捷的客户端请求代理模块  </p><ul><li>get请求</li></ul><p>使用get请求传递查询字符串，可用<code>.query()</code>，传递一个对象或字符串  </p><p><code>.set()</code>  设置<em>请求头</em>信息  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var request &#x3D; require(&#39;superagent&#39;);</span><br><span class="line">    request</span><br><span class="line">        .get(&#39;&#x2F;search&#39;)</span><br><span class="line">        .query(&#123;</span><br><span class="line">            scope: 103,</span><br><span class="line">            format: &#39;json&#39;,</span><br><span class="line">            appid: &#39;379020&#39;,</span><br><span class="line">            bk_key: &#39;火影&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        &#x2F;&#x2F; 等价于</span><br><span class="line">        &#x2F;&#x2F; .query(&#39;scope&#x3D;103&amp;format&#x3D;json&amp;appid&#x3D;379020&amp;bk_key&#x3D;火影&#39;)</span><br><span class="line">        .set(&#39;Accept&#39;, &#39;application&#x2F;json&#39;)</span><br><span class="line">        .end(function(res)&#123;</span><br><span class="line">            console.log(res.body);</span><br><span class="line">        &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>post请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    request</span><br><span class="line">        .post(&#39;&#x2F;user&#39;)</span><br><span class="line">        .set(&#39;Content-Type&#39;, &#39;application&#x2F;json&#39;)</span><br><span class="line">        .send(&#123;</span><br><span class="line">            name: &#39;leon&#39;,</span><br><span class="line">            job: &#39;engineer&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        .end(callback);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>类似于get请求的写法，当想提交数据以 <code>application/x-www-form-urlencoded</code>  类型的话，则可直接调用 <code>.type()</code>  传递form参数即可  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    request</span><br><span class="line">        .type(&#39;form&#39;)</span><br><span class="line">        .send(&#123;</span><br><span class="line">            name: &#39;leon&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        .send(&#123;</span><br><span class="line">            job: &#39;engineer&#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        .end(callback);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;br&gt;&lt;img src=&quot;http://www.blogjava.net/images/blogjava_net/amigoxie/40799/o_http%e5%8d%8f%e8%ae%ae%e5%a
      
    
    </summary>
    
    
      <category term="node javascript" scheme="http://yoursite.com/categories/node-javascript/"/>
    
    
      <category term="node nodejs" scheme="http://yoursite.com/tags/node-nodejs/"/>
    
  </entry>
  
</feed>
