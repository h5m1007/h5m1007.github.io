<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leooon Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://h5m1007.github.io/"/>
  <updated>2020-05-07T06:59:43.151Z</updated>
  <id>https://h5m1007.github.io/</id>
  
  <author>
    <name>Leon</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>打造最佳终端环境</title>
    <link href="https://h5m1007.github.io/2020/04/30/best-terminal-configure/"/>
    <id>https://h5m1007.github.io/2020/04/30/best-terminal-configure/</id>
    <published>2020-04-30T08:32:18.000Z</published>
    <updated>2020-05-07T06:59:43.151Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>新购入的mbp，需要用回之前工作的air上终端zsh，重新为新机子配置过一遍，最佳的终端环境。</p><h2 id="oh-my-zsh-iTerm2"><a href="#oh-my-zsh-iTerm2" class="headerlink" title="oh-my-zsh + iTerm2"></a>oh-my-zsh + iTerm2</h2><p>以下简称 oh-my-zsh 为 ozsh。ozsh 由何而来，高度自定义无论是在样式、插件等等方案，拓展了系统自带的 zsh。</p><p>先上最终配置界面：</p><p><img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200503150505.png" alt="ozsh"></p><p>明显比原来的高颜值且更多增强功能！👍</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>先为本机下载安装好，Git、Brew、Xcode(CLI)，科学安装方式移步至<a href="/2020/04/30/dev-env-configure/">从0开始配置新购MBP</a></p><h3 id="各个工具的安装使用"><a href="#各个工具的安装使用" class="headerlink" title="各个工具的安装使用"></a>各个工具的安装使用</h3><ul><li><p>iTerm2</p><p>  直接去官网下载或是第三方软件平台下载，推荐第三方，因为下载速度快很多。</p><p>  <a href="https://www.iterm2.com/" target="_blank" rel="noopener">官网</a><br>  <a href="https://macwk.com/soft/iterm2" target="_blank" rel="noopener">第三方</a></p><p>  下载安装完，默认样式：（盗图）</p><p>  <img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/1.png" alt="iTerm2"></p></li><li><p>oh-my-zsh</p><p>  <a href="https://github.com/robbyrussell/oh-my-zsh" target="_blank" rel="noopener">oh-my-zsh开源地址</a></p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># curl download</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># wget download</span></span><br><span class="line">sh -c <span class="string">"<span class="variable">$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>"</span></span><br></pre></td></tr></table></figure><p>  下载安装完，默认样式：（盗图）</p><p>  <img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/2.png" alt="iTerm2"></p></li><li><p>powerline</p><p>  终端字体增强插件，具体下载安装步骤移步至<a href="/2020/04/30/dev-env-configure/">从0开始配置新购MBP</a></p></li><li><p>PowerFonts</p><p>  终端字体增强插件，需要下载源项目仓库，并执行项目里的 <code>install.sh</code> 可执行文件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/powerline/fonts.git --depth=1 ./powerFonts</span><br><span class="line"><span class="comment"># jump to powerFonts folder</span></span><br><span class="line"><span class="built_in">cd</span> powerFonts</span><br><span class="line"><span class="comment"># run install shell</span></span><br><span class="line">bash ./install.sh</span><br></pre></td></tr></table></figure><p>  执行安装完，设置 iTerm2 字体，iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Text，在Font区域选中Change Font，然后找到Meslo LG字体。</p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200505114546.png" alt="iTerm2 config"></p><p>  需要同时设置好这两个位置，第二个位置如果没设置，会有空框 icon 出现。</p></li><li><p>配色方案</p><p>  配色方案在使用 vi/vim 或 colorFul log 时，会相当有用。以同样的方式，git clone 下来项目源码：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/altercation/solarized --depth=1 ./solarized</span><br><span class="line"><span class="comment"># jump to solarized-theme folder</span></span><br><span class="line"><span class="built_in">cd</span> solarized/iterm2-colors-solarized/</span><br><span class="line"><span class="comment"># open folder</span></span><br><span class="line">open .</span><br></pre></td></tr></table></figure><p>  下载后打开项目目录：（盗图）</p><p>  <img src="https://raw.githubusercontent.com/sirius1024/pubimgs/master/blogs/iterm2/8.png" alt="solarized-theme"></p><p>  依旧打开 iTerm2 配置界面，iTerm2 -&gt; Preferences -&gt; Profiles -&gt; Colors -&gt; Color Presets。</p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/Xnip2020-05-05_12-01-26.jpg" alt="iTerm2 config"></p></li><li><p>主题安装</p><p>  需要下载源项目仓库，并执行项目里的 <code>install.sh</code> 可执行文件。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/fcamblor/oh-my-zsh-agnoster-fcamblor.git ./agnoster-theme</span><br><span class="line"><span class="comment"># jump to agnoster-theme folder</span></span><br><span class="line"><span class="built_in">cd</span> agnoster-theme</span><br><span class="line"><span class="comment"># run install shell</span></span><br><span class="line">bash ./install.sh</span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/pzy/Xnip2020-05-05_14-56-13.jpeg" alt="agnoster-theme"></p><p>  再去 zsh 的配置文件 <code>vi ~/.zshrc</code>，更改主题应用。</p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/pzy/20200505155804.jpg" alt="zshrc"></p><p>  如何使用 vi 自行百度，这里修改完后 <code>:wq</code> 保存退出编辑，重启终端即主题生效。</p></li><li><p>高亮插件 zsh-syntax-highlighting</p><p>  zsh-syntax-highlighting，使用后能高亮所有关键字，如：</p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/pzy/20200506222753.png" alt="zsh-syntax-highlighting"></p><p>  这里的安装方式依旧 git clone，有些不同的是，需要把 clone 下来的项目直接放在 <code>~/.oh-my-zsh/custom/plugins/</code> 。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git</span><br></pre></td></tr></table></figure><p>  再去编辑 <code>~/.zshrc</code>。</p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/pzy/20200505160831.png" alt="zsh-syntax-highlighting"></p></li><li><p>命令自动补全插件 zsh-autosuggestion</p><p>  zsh-autosuggestion，使用后输入的命令会提示和补全，如：</p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/pzy/20200505161343.png" alt="zsh-autosuggestion"></p><p>  下载应用方式如上面👆一致。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.oh-my-zsh/custom/plugins/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions.git</span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/pzy/20200505161106.png" alt="zsh-autosuggestion"></p></li><li><p>autojump 快速跳转制定目录</p><p>  <a href="https://github.com/wting/autojump" target="_blank" rel="noopener">项目开源地址</a></p><p>  该插件可以做到，只要访问过的目录，下次访问只需要 <code>j ./folder/</code>，如：  </p><p>  <img src="https://i.loli.net/2020/05/07/iMVFHNgJ2nX4UP8.jpg" alt="autojump"></p><p>  下载安装：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#git clone project</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/wting/autojump.git</span><br><span class="line"><span class="built_in">cd</span> autojump</span><br><span class="line">./install.py</span><br></pre></td></tr></table></figure><p>  亦或者直接 <code>brew install autojump</code></p></li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>到这里，已经完成了整个终端的安装配置，最终效果再来回顾下。</p><p><img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200503150505.png" alt="ozsh"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;新购入的mbp，需要用回之前工作的air上终端zsh，重新为新机子配置过一遍，最佳的终端环境。&lt;/p&gt;
&lt;h2 id=&quot;oh-my-zsh-
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>从0开始配置新购MBP</title>
    <link href="https://h5m1007.github.io/2020/04/30/dev-env-configure/"/>
    <id>https://h5m1007.github.io/2020/04/30/dev-env-configure/</id>
    <published>2020-04-30T08:29:45.000Z</published>
    <updated>2020-05-08T06:20:59.160Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>新入手的 mbp，需要重新配置之前前端开发的环境，备份之前工作用的 air上数据，其它需要重新配置。</p><h2 id="准备步骤"><a href="#准备步骤" class="headerlink" title="准备步骤"></a>准备步骤</h2><p>需要同步的内容有：</p><ol><li><p>Safari，Chrome 两大浏览器的历史数据，如浏览记录、书签、密码、拓展插件等等，分别以 iCould 和 Google 账号的同步功能，实现迁移机器数据的完美同步。</p></li><li><p>其它软件的同步工作，如软件之前的配置，安装的插件等等。</p><p> 开发软件列表：</p><ul><li><p>iTerm2：移步<a href="/2020/04/30/best-terminal-configure/">打造最佳终端</a>;</p></li><li><p>幕布：类似于Xmind脑图软件，用登录账号来实现同步已保存至云端的数据；</p></li><li><p>SwitchHosts：本地 hosts 文件修改软件，直接导入已从其它机器导出的配置文件即可；</p></li><li><p>VsCode：重量级软件，开发必备编辑器，同步功能使用 vscode 的 Setting Sync 插件，通过已在 gist 上传的配置文件来<br>实现同步工作，可同步之前已安装插件列表、软件配置等等；</p></li></ul></li><li><p>除了以上软件的配置安装之外，额外的坑还有：</p><ul><li><p>科学上网</p><p>  没有梯子没有条件就创造条件，国内想 download 一些如 brew、pip、乃至于用 git clone 都是基本没速度可言的，针对以上软件参考解决方案如下：</p><p>  <strong>brew</strong>：按照官方安装方式，因GFW的存在，可能会遇到下载不了或没速度，所以得换种方式。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh &gt;&gt; ~/brew_install.sh</span><br></pre></td></tr></table></figure><p>  修改 brew_install.sh 文件，更换里面的镜像源  </p><p>  <code>BREW_REPO = &quot;https://github.com/Homebrew/brew”</code><br>  ==&gt;<br>  <code>BREW_REPO=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git”</code></p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502172342.png" alt="修改 brew 镜像源"></p><p>  再执行 brew_install.sh 文件，不出意外，<code>brew -v</code> 显示版本号即安装完毕。</p><p>  <strong>pip</strong>：pip 是 python 包管理工具，系统默认自带的 python2.7 安装包里 easy_install.py 是默认安装的，而 pip 需另外安装</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#使用国内镜像源：https://pypi.tuna.tsinghua.edu.cn/simple/</span></span><br><span class="line">sudo easy_install -i https://pypi.tuna.tsinghua.edu.cn/simple/ pip</span><br></pre></td></tr></table></figure></li><li><p>Git 下载速度</p><p>  系统不会自带 Git，但第一次下载安装 Brew时，会引导调用系统自动下载安装所必须的 Xcode(CLI) 以及 Git。</p><p>  进入主题，单单 Git Clone 个项目速度相当堪忧，解决此类问题，方案有几种：</p><p>  一般的方式是直接绑 hosts ( 可能本地网络原因亦或其它，反正对于我mbp无效，mmp )：</p><p>  查询以下两域名相对本地网络的 <a href="https://www.ipaddress.com" target="_blank" rel="noopener">IP 地址</a> ( 每个人查询到的可能不一 )</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">github.global.ssl.fastly.net</span><br><span class="line"></span><br><span class="line">github.com</span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502172728.png" alt="github.global.ssl.fastly.net"></p><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502173014.png" alt="github.com"></p><p>  假设查询到的 IP 地址是：  </p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">140.82.113.4 github.com</span><br><span class="line">199.232.69.194 github.global.ssl.fastly.net</span><br></pre></td></tr></table></figure><p>  写入 <code>/etc/hosts</code> 文件末尾追加</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br></pre></td></tr></table></figure><p>  因我已经安装了 SwitchHosts 该软件，直接写入配置文件立即生效。</p><p>  最后需要刷新 DNS</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo killall -HUP mDNSResponder</span><br></pre></td></tr></table></figure><p>  <strong>注</strong>：获取的 IP 因每个人不一样，且时而会更新，所以一旦速度变慢，重复以上步骤进行修改。</p><p>  另一种最直接了当的，借助现成工具实现加速：(<strong>力荐！</strong>)<br>  <a href="https://github.zhlh6.cn/" target="_blank" rel="noopener">Github加速器</a><br>  <a href="https://chrome.google.com/webstore/detail/github加速/kejahdakjmkfddgnifodfnpcklckjjpo" target="_blank" rel="noopener">Chrome插件</a></p></li><li><p>Brew</p><p>  <code>brew install xxx</code>，brew 安装软件速度依旧感人，解决方案仍然修改镜像源，修改 brew、homebrew-core 的项目 git remote 镜像源</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>"</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/brew.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> <span class="string">"<span class="variable">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core"</span></span><br><span class="line"></span><br><span class="line">git remote <span class="built_in">set</span>-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure><p>  最后更新下 brew <code>brew update</code>。</p><p>  还有一种费时费钱，挂代理：</p><p>  假设你已经用了如Shadowsocks，且也搭好服务器，不管是自己的还是自费的VPS。</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#端口1086不一定配置都是一致，按自己配置的修改</span></span><br><span class="line">ALL_PROXY=socks5://127.0.0.1:1086 brew install node</span><br></pre></td></tr></table></figure><p>  每次使用 brew 安装软件时，都需要手动加载代理，想方便的换也可把 <code>export ALL_PROXY=socks5://127.0.0.1:1086</code> 写入 <code>~/.zshrc</code> 终端配置文件里，但不建议这样做，因为可能会影响其它工具的使用。</p></li><li><p>Node</p><p>  建议直接使用 nvm Node版本管理软件，使用官方下载安装方式</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.35.3/install.sh | bash</span><br></pre></td></tr></table></figure><p>  下载安装完成后，修改 <code>~/.zshrc</code> 终端配置文件里，往后继续追加</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动终端时调用 nvm 执行文件</span></span><br><span class="line"><span class="built_in">export</span> NVM_DIR=<span class="string">"<span class="variable">$([ -z "$&#123;XDG_CONFIG_HOME-&#125;" ] &amp;&amp; printf %s "$&#123;HOME&#125;/.nvm" || printf %s "$&#123;XDG_CONFIG_HOME&#125;/nvm")</span>"</span>[ -s <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span> ] &amp;&amp; \. <span class="string">"<span class="variable">$NVM_DIR</span>/nvm.sh"</span></span><br></pre></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/h5m1007/cloud-image@master/images/20200502173809.png" alt="nvm"></p><p>  重启终端，<code>nvm install 12.16.3</code>，安装制定版本 node。</p></li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;新入手的 mbp，需要重新配置之前前端开发的环境，备份之前工作用的 air上数据，其它需要重新配置。&lt;/p&gt;
&lt;h2 id=&quot;准备步骤&quot;&gt;&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>函数优化相关</title>
    <link href="https://h5m1007.github.io/2020/04/17/learn-from-optimize/"/>
    <id>https://h5m1007.github.io/2020/04/17/learn-from-optimize/</id>
    <published>2020-04-17T08:29:28.000Z</published>
    <updated>2020-04-30T09:55:14.225Z</updated>
    
    <content type="html"><![CDATA[<h2 id="尾调用"><a href="#尾调用" class="headerlink" title="尾调用"></a>尾调用</h2><ol><li>函数A内部调用函数B，且不附加其它操作</li><li>函数A在函数最后执行阶段调用函数B</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> B();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> C()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="调用帧-调用记录"><a href="#调用帧-调用记录" class="headerlink" title="调用帧 (调用记录)"></a>调用帧 (调用记录)</h3><p>用于存储调用位置与内部变量信息，所有的调用记录形成调用栈。<br>尾调用由于是函数最后一步操作，则不需保留外层fn的调用记录，因为调用位置、内部变量等信息不会再用到，<br>用内层fn的调用记录取代外层fn的调用记录即可。</p><h3 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h3><p>只保留内层fn的调用记录，在调用记录只有一项下，极大程度节省内存。</p><h2 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h2><p>函数递归本身很耗内存，可能存在n*n的调用记录，容易栈溢出，引入尾递归调用后，由于函数最后只存在一个调用记录，<br>所不会出现栈溢出的风险。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n阶乘</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>); <span class="comment">// 产生n个调用记录，复杂度O(n)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 尾递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total); <span class="comment">// 始终产生1个调用记录，复杂度O(1)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ==&gt; 柯里化尾递归调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span>(<span class="params">fn, n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">m</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span>(<span class="params">n, total</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( n === <span class="number">1</span> ) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;尾调用&quot;&gt;&lt;a href=&quot;#尾调用&quot; class=&quot;headerlink&quot; title=&quot;尾调用&quot;&gt;&lt;/a&gt;尾调用&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;函数A内部调用函数B，且不附加其它操作&lt;/li&gt;
&lt;li&gt;函数A在函数最后执行阶段调用函数B&lt;/li&gt;
&lt;/ol&gt;
&lt;f
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>各种应用工具类实现</title>
    <link href="https://h5m1007.github.io/2020/04/09/learn-from-js/"/>
    <id>https://h5m1007.github.io/2020/04/09/learn-from-js/</id>
    <published>2020-04-09T08:07:43.000Z</published>
    <updated>2020-05-30T02:38:40.873Z</updated>
    
    <content type="html"><![CDATA[<h2 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h2><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copy1 = &#123; ...&#123;<span class="attr">x</span>: <span class="number">1</span>&#125; &#125;; <span class="comment">// ...&#123;&#125; 解构实现</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> copy2  = <span class="built_in">Object</span>.assign(&#123;&#125;, &#123;<span class="attr">x</span>: <span class="number">1</span>&#125;); <span class="comment">// object.assign 对象合并实现</span></span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: &#123;<span class="attr">x</span>: <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj)); <span class="comment">// JSON.stringify 序列化对象成字符串再转对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归处理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepCopy</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> copy = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">let</span> k <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( obj.hasOwnProperty(k) ) &#123;</span><br><span class="line">      copy[k] = <span class="keyword">typeof</span> obj[k] === <span class="string">'object'</span> ? deepCopy(obj[k]) : obj[k];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模拟setInterval"><a href="#模拟setInterval" class="headerlink" title="模拟setInterval"></a>模拟setInterval</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">setTimeout( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 这里不能用箭头函数，否则拿不到 arguments</span></span><br><span class="line">  <span class="comment">// func</span></span><br><span class="line">  setTimeout( <span class="built_in">arguments</span>.callee, <span class="number">500</span>);</span><br><span class="line">&#125;, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><h2 id="Event-Bus"><a href="#Event-Bus" class="headerlink" title="Event Bus"></a>Event Bus</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.events = <span class="keyword">this</span>.events || <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addListener( type, fn ) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="keyword">this</span>.events.get(type) ) &#123;</span><br><span class="line">      <span class="keyword">this</span>.events.set(type, fn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit( type ) &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = <span class="keyword">this</span>.events.get(type);</span><br><span class="line"></span><br><span class="line">    handle.apply(<span class="keyword">this</span>, [...arguments].slice(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> emitter = <span class="keyword">new</span> EventBus;</span><br><span class="line"></span><br><span class="line">emitter.addListener(<span class="string">'event'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...arguments);</span><br><span class="line">&#125;);</span><br><span class="line">emitter.emit(<span class="string">'event'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>);</span><br></pre></td></tr></table></figure><h2 id="双向绑定"><a href="#双向绑定" class="headerlink" title="双向绑定"></a>双向绑定</h2><p>简易版主要理解实现核心，getter() &amp; setter()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> input = <span class="built_in">document</span>.getElementById(<span class="string">'input'</span>);</span><br><span class="line"><span class="keyword">const</span> html = <span class="built_in">document</span>.getElementById(<span class="string">'html'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">'text'</span>, &#123;</span><br><span class="line">  configurable: <span class="literal">true</span>, <span class="comment">// 可配置，如对对象key，value进行配置</span></span><br><span class="line">  enumerable: <span class="literal">true</span>, <span class="comment">// 可枚举，如对被循环遍历</span></span><br><span class="line">  <span class="keyword">get</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'get data'</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>( newValue ) &#123;</span><br><span class="line">    input.value = newValue;</span><br><span class="line">    html.innerHTML = newValue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener( <span class="string">'keyup'</span>, e =&gt; &#123;</span><br><span class="line">  obj.text = e.target.value;</span><br><span class="line">&#125; );</span><br></pre></td></tr></table></figure><h2 id="滚动更新"><a href="#滚动更新" class="headerlink" title="滚动更新"></a>滚动更新</h2><p>所参与计算的需要的变量值：</p><ul><li><p>可视窗口大小：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 标准浏览器及IE9+ || 标准浏览器及低版本IE || 低版本混杂模式</span></span><br><span class="line"><span class="comment">// jq: $(window).height()</span></span><br><span class="line"><span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight</span><br></pre></td></tr></table></figure></li><li><p>窗口顶部与文档顶部间的距离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jq: $(document).scrollTop();</span></span><br><span class="line"><span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop</span><br></pre></td></tr></table></figure></li><li><p>元素顶部与文档顶部间的距离</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jq: $(el).offset().top</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElTop</span>(<span class="params">el, initValue = <span class="number">0</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _top = el.offsetTop + initValue;</span><br><span class="line">  <span class="keyword">const</span> parent = el.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( parent !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    _top += parent.clientTop;</span><br><span class="line">    getElTop(parent, _top); <span class="comment">// 尾递归</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">return</span> _top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 循环实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getElTopLoop</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _top = el.offsetTop;</span><br><span class="line">  <span class="keyword">let</span> parent = el.offsetParent;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>( parent !== <span class="literal">null</span> ) &#123;</span><br><span class="line">    _top += parent.offsetTop + parent.clientTop;</span><br><span class="line">    parent = parent.offsetParent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> _top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getBoundingClientRect()</span></span><br><span class="line"><span class="keyword">const</span> EL = <span class="built_in">document</span>.getElementById(<span class="string">'#el'</span>);</span><br><span class="line">EL.getBoundingClientRect().top;</span><br></pre></td></tr></table></figure></li></ul><h3 id="场景：判断元素是否进入视区"><a href="#场景：判断元素是否进入视区" class="headerlink" title="场景：判断元素是否进入视区"></a>场景：判断元素是否进入视区</h3><ol><li>方式一：根据元素到文档顶部的距离是否小于当前视口相对于文档顶部的距离</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isInSight</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> clientHeight = <span class="built_in">window</span>.innerHeight || <span class="built_in">document</span>.documentElement.clientHeight || <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">  <span class="keyword">const</span> scrollTop = <span class="built_in">window</span>.pageYOffset || <span class="built_in">document</span>.documentElement.scrollTop || <span class="built_in">document</span>.body.scrollTop;</span><br><span class="line">  <span class="keyword">const</span> scrollHeight = clientHeight + scrollTop;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getElTop(el) &lt; scrollHeight;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImg</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !el.src ) &#123;</span><br><span class="line">    el.src = el.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkImgs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> imgs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'img'</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.from(imgs).forEach( <span class="function"><span class="params">img</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( isInSight(img) ) &#123;</span><br><span class="line">      loadImg(el);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, checkImgs, <span class="literal">false</span>);</span><br><span class="line"><span class="built_in">window</span>.onload = checkImgs;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IntersectionObserver</span></span><br></pre></td></tr></table></figure><h3 id="模拟-Promise"><a href="#模拟-Promise" class="headerlink" title="模拟 Promise"></a>模拟 Promise</h3><ul><li><p>类写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 实例化时接受外部传入自执行函数，该函数里会定义一些异步行为；</span></span><br><span class="line"><span class="comment">2. 三个状态(实例成员)：等待、成功返回值、拒绝原因；</span></span><br><span class="line"><span class="comment">3. 两个方法(静态成员)：resolve、reject；</span></span><br><span class="line"><span class="comment">4. 自执行函数接受已在类里定义好的俩方法 resolve、reject；</span></span><br><span class="line"><span class="comment">5. 共享方法 .then()：本质返回新的 Promise，接受俩外部声明好的 resolve、reject，.then() 回调里判断当前状态执行 resolve、reject；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(fn) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = <span class="string">'pendding'</span>;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">this</span>.reason = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="keyword">this</span>.state === <span class="string">'pendding'</span> ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ( <span class="keyword">this</span>.state === <span class="string">'pendding'</span> ) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = <span class="string">'rejected'</span>;</span><br><span class="line">        <span class="keyword">this</span>.reason = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      fn(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      reject(e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  then(onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'fulfilled'</span>:</span><br><span class="line">        onFulfilled();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'rejected'</span>:</span><br><span class="line">        onRejected();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数写法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  self.state = <span class="string">'pedding'</span>;</span><br><span class="line">  self.value = <span class="literal">undefined</span>;</span><br><span class="line">  self.reason = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( self.state === <span class="string">'pedding'</span> ) &#123;</span><br><span class="line">      self.state = <span class="string">'fulfilled'</span>;</span><br><span class="line">      self.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( self.state === <span class="string">'pedding'</span> ) &#123;</span><br><span class="line">      self.state = <span class="string">'rejected'</span>;</span><br><span class="line">      self.reason = value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    reject(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> self = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (self.state) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'fulfilled'</span>:</span><br><span class="line">      onFulfilled();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'rejected'</span>:</span><br><span class="line">      onRejected();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖/节流"></a>防抖/节流</h3><ul><li>防抖</li></ul><p>当任务频繁触发时，只有任务触发时间间隔超过指定间隔时，任务才会执行</p><p>场景：鼠标连续点击，输入框输入联想搜索请求接口</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 利用闭包缓存状态变量</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, threshhold</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Wrong Params Type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line"></span><br><span class="line">    timer = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      fn.call(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;, threshhold);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>节流</li></ul><p>指定时间阈值内，无论触发几次都只会执行一次</p><p>场景：滚动监听、鼠标跟随、动画</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 利用闭包缓存限制标志位及开始时间戳</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, threshhold = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( !(fn <span class="keyword">instanceof</span> <span class="built_in">Function</span>) ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Wrong Params Type"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now();</span><br><span class="line">  <span class="keyword">let</span> limited = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="built_in">Date</span>.now();</span><br><span class="line"></span><br><span class="line">    limited = limited &amp;&amp; current - start &lt; threshhold;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!limited) &#123;</span><br><span class="line">      fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">      limited = <span class="literal">true</span>;</span><br><span class="line">      start = <span class="built_in">Date</span>.now();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟-call"><a href="#模拟-call" class="headerlink" title="模拟 call"></a>模拟 call</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 传入调用函数上下文</span></span><br><span class="line"><span class="comment">2. 缓存当前调用函数 this</span></span><br><span class="line"><span class="comment">3. 内部自执行调用函数，并传入剩余参数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Function</span>.prototype._call = <span class="function"><span class="keyword">function</span>(<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Current This Not Function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line">  </span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result = context.fn(...args);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟-apply"><a href="#模拟-apply" class="headerlink" title="模拟 apply"></a>模拟 apply</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. apply(this, [])</span></span><br><span class="line"><span class="comment">2. apply 第二个参数接收数组</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Function</span>.prototype._apply = <span class="function"><span class="keyword">function</span>(<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Current Scope Not Function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  context.fn = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( <span class="built_in">arguments</span>[<span class="number">1</span>] ) &#123;</span><br><span class="line">    result = context.fn(...arguments[<span class="number">1</span>]);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = context.fn();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.fn;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟-bind"><a href="#模拟-bind" class="headerlink" title="模拟 bind"></a>模拟 bind</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 返回函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">Function</span>.prototype._bind = <span class="function"><span class="keyword">function</span>(<span class="params">context = window</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> ( <span class="keyword">typeof</span> <span class="keyword">this</span> !== <span class="string">'function'</span> ) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Current Scope Not Function"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> _this = <span class="keyword">this</span>; <span class="comment">// 缓存当前调用对象</span></span><br><span class="line">  <span class="keyword">let</span> args = [...arguments].slice(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">this</span> <span class="keyword">instanceof</span> F ) &#123; <span class="comment">// 兼顾 new 的情况</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> _this(...args, ...arguments);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> _this.apply(context, args.concat(...arguments));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模拟-new"><a href="#模拟-new" class="headerlink" title="模拟 new"></a>模拟 new</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype._new = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> obj = &#123;</span><br><span class="line">      <span class="comment">// 新建对象的原型指向 fn 原型，使之拥有 fn 的方法</span></span><br><span class="line">      <span class="comment">// __proto__ 字面量 &#123;&#125;，隐式 new Object 实例化了对象，实例化对象拥有隐式 __proto__</span></span><br><span class="line">      __proto__: fn.prototype</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    fn.call(obj, ...arguments); <span class="comment">// call 使之新建对象拥有 fn 的实例成员</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> obj; <span class="comment">// 返回已实例化后的对象</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;深浅拷贝&quot;&gt;&lt;a href=&quot;#深浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;深浅拷贝&quot;&gt;&lt;/a&gt;深浅拷贝&lt;/h2&gt;&lt;h3 id=&quot;浅拷贝&quot;&gt;&lt;a href=&quot;#浅拷贝&quot; class=&quot;headerlink&quot; title=&quot;浅拷贝&quot;&gt;&lt;/a&gt;浅拷
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>知识梳理一</title>
    <link href="https://h5m1007.github.io/2019/06/27/knowledge-combing/"/>
    <id>https://h5m1007.github.io/2019/06/27/knowledge-combing/</id>
    <published>2019-06-27T02:36:10.000Z</published>
    <updated>2020-05-12T14:37:37.443Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h2><ol><li><p>for循环</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">  <span class="comment">// 缓存arr长度，这一步新版本的浏览器已自行实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>forEach</p><p>es5的forEach，实际性能比for还差</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.forEach( <span class="function">(<span class="params"> value, index </span>) =&gt;</span> &#123;&#125; )</span><br></pre></td></tr></table></figure><p><em>不能break中断循环，且无法return</em></p></li><li><p>map</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">arr.map( <span class="function">(<span class="params"> value, index </span>) =&gt;</span> &#123;&#125; )</span><br></pre></td></tr></table></figure><ul><li>支持return</li></ul><ol start="4"><li>for-of</li></ol><p>es6的for-of</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> index <span class="keyword">of</span> arr ) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>支持数组，类数组对象，字符串</li><li>支持break, continue, return</li></ul><ol start="5"><li>for-in</li></ol><p>遍历对象，可遍历数组但数组的下标会被转成字符串</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  key1: <span class="string">'value1'</span>,</span><br><span class="line">  key2: <span class="string">'value2'</span>,</span><br><span class="line">  key3: <span class="string">'value3'</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> key <span class="keyword">in</span> obj ) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`obj.<span class="subst">$&#123;key&#125;</span> = <span class="subst">$&#123;obj[key]&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="6"><li>退出循环</li></ol><table><thead><tr><th align="center">序号</th><th align="center">方法</th><th align="center">break</th><th align="center">continue</th><th align="center">return</th><th align="center">return true</th><th align="center">return false</th><th align="center">结论</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">for循环</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">√</td></tr><tr><td align="center">2</td><td align="center">Array.forEach()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">×</td></tr><tr><td align="center">3</td><td align="center">for…in</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">√</td></tr><tr><td align="center">4</td><td align="center">Array.map()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">×</td></tr><tr><td align="center">5</td><td align="center">Array.some()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">√</td></tr><tr><td align="center">6</td><td align="center">Array.every()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">成功</td><td align="center">跳出本次循环</td><td align="center">成功</td><td align="center">√</td></tr><tr><td align="center">7</td><td align="center">Array.filter()</td><td align="center">不合法</td><td align="center">不合法</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">跳出本次循环</td><td align="center">×</td></tr></tbody></table><h2 id="Array-reduce"><a href="#Array-reduce" class="headerlink" title="Array.reduce()"></a>Array.reduce()</h2><p>对数组的每一项升序执行</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].reduce( <span class="function">(<span class="params">accumulator, currentValue, currentIndex, array</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// accumulator 累计器，默认起始值为initialValue</span></span><br><span class="line">  <span class="comment">// currentValue 当前值</span></span><br><span class="line">  <span class="comment">// currentIndex 当前值下标</span></span><br><span class="line">  <span class="comment">// array调用reduce的数组</span></span><br><span class="line">  <span class="comment">// initialValue accumulator默认起始值，当没指定时则以数组第一项为准</span></span><br><span class="line">&#125;, initialValue )</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;遍历&quot;&gt;&lt;a href=&quot;#遍历&quot; class=&quot;headerlink&quot; title=&quot;遍历&quot;&gt;&lt;/a&gt;遍历&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;for循环&lt;/p&gt;
&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>require</title>
    <link href="https://h5m1007.github.io/2019/06/25/learn-from-requireJs/"/>
    <id>https://h5m1007.github.io/2019/06/25/learn-from-requireJs/</id>
    <published>2019-06-25T07:20:21.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="require-ensure"><a href="#require-ensure" class="headerlink" title="require.ensure()"></a>require.ensure()</h2><ul><li>代码分隔 基于webpack，针对体积大的模块单独导出js文件，用于异步调用，可结合同步代码</li><li>用法：require.ensure( [], fn(), ‘’ )<br>参数1为异步函数的依赖<br>参数2为回调, 异步调用的函数写于这里<br>参数3为chunk命名</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 异步按需加载的方式导出swiper</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">getSwiper</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="built_in">require</span>.ensure(</span><br><span class="line">        [],</span><br><span class="line">        <span class="built_in">require</span> =&gt; &#123;</span><br><span class="line">          res(<span class="built_in">require</span>(<span class="string">'xxx/swiper'</span>));</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'chunck-swiper'</span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;require-ensure&quot;&gt;&lt;a href=&quot;#require-ensure&quot; class=&quot;headerlink&quot; title=&quot;require.ensure()&quot;&gt;&lt;/a&gt;require.ensure()&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代码分隔 基于webpa
      
    
    </summary>
    
    
    
      <category term="javascript require" scheme="https://h5m1007.github.io/tags/javascript-require/"/>
    
  </entry>
  
  <entry>
    <title>nodejs 开发记录</title>
    <link href="https://h5m1007.github.io/2019/06/25/learn-from-nodejs/"/>
    <id>https://h5m1007.github.io/2019/06/25/learn-from-nodejs/</id>
    <published>2019-06-25T07:04:45.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nodejs中一些路径相关概念"><a href="#nodejs中一些路径相关概念" class="headerlink" title="nodejs中一些路径相关概念"></a>nodejs中一些路径相关概念</h2><p>__dirname：获得当前执行文件所在目录完整目录名<br>__filename：获得当前执行文件完整绝对路径文件名<br>process.cwd()：获得当前node命令执行目录名<br>path.resolve()：返回相对当前工作目录的绝对路径</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;nodejs中一些路径相关概念&quot;&gt;&lt;a href=&quot;#nodejs中一些路径相关概念&quot; class=&quot;headerlink&quot; title=&quot;nodejs中一些路径相关概念&quot;&gt;&lt;/a&gt;nodejs中一些路径相关概念&lt;/h2&gt;&lt;p&gt;__dirname：获得当前执行文件
      
    
    </summary>
    
    
    
      <category term="javascript node" scheme="https://h5m1007.github.io/tags/javascript-node/"/>
    
  </entry>
  
  <entry>
    <title>react 开发记录一</title>
    <link href="https://h5m1007.github.io/2019/06/25/learn-from-react/"/>
    <id>https://h5m1007.github.io/2019/06/25/learn-from-react/</id>
    <published>2019-06-25T07:01:28.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h2 id="exports-amp-amp-import"><a href="#exports-amp-amp-import" class="headerlink" title="exports &amp;&amp; import"></a>exports &amp;&amp; import</h2><ol><li>module exports export import<br>由于nodejs采用CommonJS模块规范，其中module表示一个对象变量，本身的exports属性是对外接口。因node为每个模块提供一个exports变量，所以有两种模块导出方式：<code>module.exports = { obj }</code> 和 <code>exports.obj = { obj }</code>；<br>而ES6的export和export default，导出对外接口以提供给import导入，需要注意的是：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-index.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  import-index.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">var</span> &#125; <span class="keyword">from</span> ‘<span class="keyword">export</span>-index’;</span><br></pre></td></tr></table></figure>由export直接导出的，import导入必须是对象且需知变量名</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-index.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">var</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">var</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  import-index.js</span></span><br><span class="line"><span class="keyword">import</span> _var <span class="keyword">from</span> ‘<span class="keyword">export</span>-index’;</span><br></pre></td></tr></table></figure><p>而由export default导出的，import导入可以是自定义变量名</p><h2 id="class-A-extends-B"><a href="#class-A-extends-B" class="headerlink" title="class A extends B {}"></a>class A extends B {}</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(params) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">super指向父类B的构造函数</span></span><br><span class="line"><span class="comment">但super内部的this指向A</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">super</span>(params); <span class="comment">// B.prototype.constructor.call(this, params)</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组件间的引用"><a href="#组件间的引用" class="headerlink" title="组件间的引用"></a>组件间的引用</h2><p>当子组件调用父组件函数时，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// Parent</span></span><br><span class="line"><span class="keyword">import</span> Child <span class="keyword">from</span> <span class="string">'./child.jsx'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"><span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.state = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handleFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"><span class="comment">// 这里使用箭头函数，当子组件调用时</span></span><br><span class="line"><span class="comment">// 可以获得当前作用域的this</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> <span class="attr">handleFn</span>=<span class="string">&#123;handleFn&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Child</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="keyword">constructor</span>(props) &#123;</span><br><span class="line"><span class="keyword">super</span>(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; handleFn &#125; = <span class="keyword">this</span>.props;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">&lt;div onClick=&#123; () =&gt; handleFn() &#125; /&gt;</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="react中的注释："><a href="#react中的注释：" class="headerlink" title="react中的注释："></a>react中的注释：</h2><p>1.单行注释–<br>{/* 注释内容 */} </p><p>2.多行注释–<br>/*<br>注释1<br>注释2<br>*/<br>ps：切记不能用 <code>&lt;!-- 注释 --&gt;</code></p><h2 id="react-生命周期"><a href="#react-生命周期" class="headerlink" title="react 生命周期"></a>react 生命周期</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">constructor</span>(props) &#123; </span><br><span class="line"><span class="comment">// 只调用一次</span></span><br><span class="line"><span class="keyword">super</span>(props); <span class="comment">// 必须存在 </span></span><br><span class="line">&#125; <span class="comment">// 初始化</span></span><br><span class="line">↓</span><br><span class="line">componentWillMount() &#123; </span><br><span class="line"><span class="comment">// 只调用一次，此时可修改state</span></span><br><span class="line">&#125; <span class="comment">// 组件即将挂载</span></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 第一次 render() &#123;&#125;</span></span><br><span class="line">↓</span><br><span class="line">componentDidMount() &#123;</span><br><span class="line">只调用一次，此时真实的DOM已被渲染出来</span><br><span class="line">&#125; <span class="comment">// 组件完成挂载</span></span><br><span class="line">↓</span><br><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line"><span class="comment">// 组件接收到新的props</span></span><br><span class="line"><span class="comment">// 父组件发生render时，子组件调用</span></span><br><span class="line"><span class="comment">// 可用于组件间通信，父组件作为中间层</span></span><br><span class="line">&#125; <span class="comment">// 组件即将接收父组件值</span></span><br><span class="line">↓</span><br><span class="line">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class="line"><span class="comment">// 组件是否应当渲染新的props和state</span></span><br><span class="line">&#125; <span class="comment">// 返回false不执行下一个生命周期</span></span><br><span class="line">↓</span><br><span class="line">componentWillUpdate(nextProps, nextState) &#123;</span><br><span class="line"><span class="comment">// 接收到新的props和state之后，渲染之前</span></span><br><span class="line">&#125; <span class="comment">// 组件即将更新</span></span><br><span class="line">↓</span><br><span class="line"><span class="comment">// 第二次 render() &#123;&#125;</span></span><br><span class="line">↓</span><br><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line"><span class="comment">// 完成新的props和state更新，渲染之后调用</span></span><br><span class="line"><span class="comment">// 此时可访问真实DOM</span></span><br><span class="line">&#125; <span class="comment">// 组件完成更新</span></span><br><span class="line">↓</span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line"><span class="comment">// 组件被移除前调用</span></span><br><span class="line">&#125; <span class="comment">// 组件卸载</span></span><br></pre></td></tr></table></figure><ul><li>在render阶段，只能经 this.prop 和 this.state 访问数据，不能改变状态，不能修改DOM输出</li></ul><h2 id="react-指定位置render"><a href="#react-指定位置render" class="headerlink" title="react 指定位置render"></a>react 指定位置render</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildComponent</span> <span class="title">extend</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">close</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'childClass'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( div ) &#123;</span><br><span class="line">    ReactDOM.unmountComponentAtNode(div);</span><br><span class="line">    div.parentNode.removeChild(div);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> div = <span class="built_in">document</span>.createElement(<span class="string">'childClass'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> ( !div ) &#123;</span><br><span class="line">    div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>);</span><br><span class="line">    div.className = <span class="string">'childClass'</span>;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(div);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">ChildComponent</span> /&gt;</span></span>, div);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="性能篇"><a href="#性能篇" class="headerlink" title="性能篇"></a>性能篇</h1><ol><li><p>使用 pureComponent<br>内部处理的是浅比较，应用于业务场景，数据变化不复杂的情况</p></li><li><p>defaultProps 初始化组件属性值<br>引入 ``, 避免组件重复渲染</p></li><li><p>展示组件 / 容器组件<br>抽离业务逻辑至容器组件，纯 UI 层面放置展示组件</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Layout <span class="keyword">from</span> <span class="string">'./Layout'</span>; <span class="comment">// 展示组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutContainer</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...业务逻辑 fn</span></span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Layout</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导出接受展示组件的函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">render() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;exports-amp-amp-import&quot;&gt;&lt;a href=&quot;#exports-amp-amp-import&quot; class=&quot;headerlink&quot; title=&quot;exports &amp;amp;&amp;amp; import&quot;&gt;&lt;/a&gt;exports &amp;amp;&amp;amp
      
    
    </summary>
    
    
    
      <category term="react" scheme="https://h5m1007.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>DvaJS 一些概念</title>
    <link href="https://h5m1007.github.io/2019/06/21/dva/"/>
    <id>https://h5m1007.github.io/2019/06/21/dva/</id>
    <published>2019-06-21T08:39:37.000Z</published>
    <updated>2020-05-13T03:39:16.478Z</updated>
    
    <content type="html"><![CDATA[<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├── /dist/                    <span class="comment"># 编译打包后目录</span></span><br><span class="line">├── /src/                     <span class="comment"># 源码目录</span></span><br><span class="line">│ ├── /assets/                <span class="comment"># 静态资源目录</span></span><br><span class="line">│ ├── /components/            <span class="comment"># UI组件目录</span></span><br><span class="line">│ │ ├── /Forbid/              <span class="comment"># 业务相关组件</span></span><br><span class="line">│ │ │ └── forbid.css</span><br><span class="line">│ │ │ └── index.js</span><br><span class="line">│ ├── /containers/            <span class="comment"># 容器组件目录</span></span><br><span class="line">│ │ └── Forbid.js</span><br><span class="line">│ ├── /models/                <span class="comment"># Model 一个模块对应一个model</span></span><br><span class="line">│ ├── /services/              <span class="comment"># 各模块接口请求</span></span><br><span class="line">│ ├── /utils/                 <span class="comment"># 公用工具</span></span><br><span class="line">└── index.ejs</span><br><span class="line">└── index.js                  <span class="comment"># 入口文件</span></span><br><span class="line">└── router.js                 <span class="comment"># 路由文件</span></span><br></pre></td></tr></table></figure><h2 id="component"><a href="#component" class="headerlink" title="component"></a>component</h2><hr><p>UI组件，由开发者提供，负责UI视觉层；所有数据由props提供，不适用任何 <code>Redux</code> 的 API</p><h2 id="container"><a href="#container" class="headerlink" title="container"></a>container</h2><hr><p>容器组件，由 <code>react-redux</code> 自动生成，管理数据及业务逻辑，不负责UI实现；使用 <code>Redux</code> 的 API</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UiComponent = <span class="function">(<span class="params">&#123;state, dispatch, location, history&#125;</span>) =&gt;</span> ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapStateToProps = <span class="function">(<span class="params">state, ownProps</span>) =&gt;</span> state;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mapDispatchToProps = <span class="function">(<span class="params">dispatch, ownProps</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        onAction: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            dispatch(&#123;</span><br><span class="line">                type: <span class="string">''</span>,</span><br><span class="line">                &#123;data&#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> connect(</span><br><span class="line">    mapStateToProps,</span><br><span class="line">    mapDispatchToProps</span><br><span class="line">)(UiComponent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 经connect后的组件，可获取到state, dispatch, location, history</span></span><br></pre></td></tr></table></figure><h2 id="model"><a href="#model" class="headerlink" title="model"></a>model</h2><hr><p>dva最为重要的部分，可当做是对redux、react-redux、redux-saga的封装</p><h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>model的命名空间，全局state的一个属性，即state.namespace</p><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>对应的是 <code>reducer</code> 的 <code>initialState</code></p><p><strong>额外说明</strong><br>react 的 state 和 redux 的 state 不是一个性质的东西，react 中的 state 是组件内部本身的状态，而 redux 的 state 则是 redux 本身的数据，提供给 react 使用，redux 也可提供给其它框架使用。</p><h3 id="subscription"><a href="#subscription" class="headerlink" title="subscription"></a>subscription</h3><p><em>dom ready后执行</em><br>订阅某些数据源，根据情况 <code>dispatch</code> 某些 <code>action</code></p><h3 id="effects"><a href="#effects" class="headerlink" title="effects"></a>effects</h3><p>对应的是 <code>redux-saga</code>，简化了使用方式<br>处理异步操作，发起异步action，<em>不能直接修改state</em><br>本身为对象，存放的只能是 <code>generator</code> 生成器函数，每个函数携带两个参数 <code>action</code> 和 <code>effects</code>，<br>而 <code>effects</code> 包含 <code>put</code>、<code>call</code>、<code>select</code> 三个字段，其中 <code>put</code> 触发 <code>action</code>，<code>call</code> 调用异步处理逻辑，<code>select</code> 从 <code>state</code> 中获取数据</p><h3 id="reducers"><a href="#reducers" class="headerlink" title="reducers"></a>reducers</h3><p>发起同步action<br><em>唯一可以修改state的地方</em><br>本身为对象，存放的每个函数都携带两个参数：<code>state</code> 和 <code>action</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;目录结构&quot;&gt;&lt;a href=&quot;#目录结构&quot; class=&quot;headerlink&quot; title=&quot;目录结构&quot;&gt;&lt;/a&gt;目录结构&lt;/h2&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>docker</title>
    <link href="https://h5m1007.github.io/2019/06/21/docker/"/>
    <id>https://h5m1007.github.io/2019/06/21/docker/</id>
    <published>2019-06-21T07:29:09.000Z</published>
    <updated>2020-04-30T06:38:46.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="dockerfile-和-docker-compose-的关系"><a href="#dockerfile-和-docker-compose-的关系" class="headerlink" title="dockerfile 和 docker-compose 的关系"></a>dockerfile 和 docker-compose 的关系</h1><p>背景是需要搭建个wordpress。</p><p>Q: 假如你不用 docker ，搭建 wordpress 怎么弄？<br>A: 先找台 server ，假设其 OS 为 Ubuntu ，然后按照文档一步步敲命令，写配置.</p><p>Q: 用 docker 呢？<br>A: 随便找台 server ，不管什么操作系统，只要支持 docker 就行，<br>执行终端命令 <code>docker run ubuntu</code>，docker 会从官方源里拉取最新的 Ubuntu 镜像，<br>可以认为你开了个 Ubuntu 虚拟机，然后一步步安装，跟上面一样。</p><p>BUT，但是这样安装有个显著的缺点，一旦 container (容器) 被删，你做的工作就都没了。<br>当然可以用命令<code>docker commit</code> 来保存成镜像，这样就可以复用了。</p><p>但是镜像一般比较大，而且只分享镜像的话，别人也不知道你这镜像到底包含什么，<br>这些问题都不利于分享和复用。一个直观的解决方案就是，写个脚本把安装过程全部记录下来，<br>这样再次安装的时候，执行脚本就行了。</p><p>而 Dockerfile 就是这样的脚本，它记录了一个镜像的制作过程。有了 <em>Dockerfile</em>, 只要执行<br><code>docker build</code> ，就能制作镜像，而且 <em>Dockerfile</em> 就是文本文件，修改也很方便。</p><p>现在有了 wordpress 的镜像，只需要 docker run 就把 wordpress 启动起来了。</p><p>如果仅仅是 wordpress, 这也就够了。但是很多时候，需要多个镜像合作才能启动一个服务，<br>比如前端要有 nginx ，数据库 mysql , 邮件服务等等，当然你可以把所有这些都弄到一个镜像里去，<br>但这样做就无法复用了。更常见的是, nginx, mysql, smtp 都分别是个镜像，然后这些镜像合作，<br>共同服务一个项目。<em>docker-compose</em> 就是解决这个问题的。你的项目需要哪些镜像，每个镜像怎么<br>配置，要挂载哪些 volume, 等等信息都包含在 docker-compose.yml 里。要启动服务，<br>只需要执行命令 <code>docker-compose up</code> 就行，停止也只需要 <code>docker-compse stop/down</code>。</p><p>简而言之， <em>Dockerfile</em> 记录单个镜像的构建过程，<em>docker-compse.yml</em> 记录一个<br>项目(project, 一般是多个镜像)的构建过程。</p><p>至于结合使用 dockerfile+docker-compose, 是因为 <em>docker-compose.yml</em> 本身没有镜像<br>构建的信息，如果镜像是从 <code>docker registry</code> 拉取下来的，那么 <em>Dockerfile</em> 就不需要；<br>如果镜像是需要 build 的，那就需要提供 <em>Dockerfile</em>。</p><h1 id="Dockerfile、Docker镜像和-Docker容器的关系"><a href="#Dockerfile、Docker镜像和-Docker容器的关系" class="headerlink" title="Dockerfile、Docker镜像和 Docker容器的关系"></a>Dockerfile、Docker镜像和 Docker容器的关系</h1><p><a href="http://blog.csdn.net/zhousenshan/article/details/51501734" target="_blank" rel="noopener">click</a></p><h1 id="Dockerfile-详解"><a href="#Dockerfile-详解" class="headerlink" title="Dockerfile 详解"></a>Dockerfile 详解</h1><p><a href="http://blog.csdn.net/mozf881/article/details/55798811" target="_blank" rel="noopener">click</a></p><h1 id="多进程管理工具-Supervisor-Dockerfile"><a href="#多进程管理工具-Supervisor-Dockerfile" class="headerlink" title="多进程管理工具 - Supervisor + Dockerfile"></a>多进程管理工具 - Supervisor + Dockerfile</h1><p><a href="https://www.linuxprobe.com/docker-process-management1.html" target="_blank" rel="noopener">click</a></p><h1 id="linux-docker-dockerfile-supervisor-终端命令回忆录"><a href="#linux-docker-dockerfile-supervisor-终端命令回忆录" class="headerlink" title="linux + docker + dockerfile + supervisor 终端命令回忆录"></a>linux + docker + dockerfile + supervisor 终端命令回忆录</h1><p>查看端口情况<br><code>netstat -ntlp</code></p><p>查看端口映射关系<br><code>iptables -t nat -L -n</code></p><p>端口映射 - linux<br><code>iptables -t nat -A DOCKER -p tcp --dport 8001 -j DNAT --to-destination x.x.x.x:8000</code></p><p>sudo docker run –detach <br>  –hostname gitlab.example.com <br>  –publish 443:443 –publish 88:80 –publish 23:22 <br>  –name gitlab <br>  –restart always <br>  –volume /srv/gitlab/config:/etc/gitlab <br>  –volume /srv/gitlab/logs:/var/log/gitlab <br>  –volume /srv/gitlab/data:/var/opt/gitlab <br>  gitlab/gitlab-ce:latest</p><p>关闭端口映射关系 (需要重启生效)<br><code>iptables -A DOCKER -p tcp --dport 8001 -j DROP</code></p><p>端口映射 - mac<br><code>lsof -i -P | grep docke</code><br><code>sudo vim /etc/pf.anchors/eclipse.tomcat.forwarding</code><br><code>rdr pass on lo0 inet proto tcp from any to 127.0.0.1 port 3333 -&gt; x.x.x.x port 3333</code><br><code>sudo pfctl -ef /etc/pf-tomcat.conf</code></p><h1 id="导致docker自启不了可能的原因"><a href="#导致docker自启不了可能的原因" class="headerlink" title="导致docker自启不了可能的原因"></a>导致docker自启不了可能的原因</h1><ol><li>宿主机自启服务的端口与容器自启服务端口有冲突</li></ol><p>查看docker容器IP<br><code>docker inspect auto_testing | grep IPAddress</code></p><p>查看正在运行容器 &amp; 查看所有包括停止的容器<br><code>docker ps</code> &amp; <code>docker ps -a</code></p><p>启动已停止的容器<br><code>docker start auto_testing</code></p><p>进入容器并执行指定命令（Ctrl + P + Q 退出容器保持后台运行）<br><code>docker exec -it auto_testing /bin/bash</code></p><p>查看容器在它生命周期的记录<br><code>docker logs auto_testing</code><br><em>注意事项</em> 当run容器后，启动不了容器，检查下log可发现问题</p><p>基于现有容器提交镜像至本地库<br><code>docker commit -m=&quot;for auto testing&quot; --author=&quot;xxx&quot; auto_testing auto_testing/ubuntu:v1</code></p><p>pull下来的镜像可能某些工具缺失<br><code>apt-get update &amp;&amp; \apt-get install -y vim procps net-tools git</code></p><p>后台启动容器并指定端口映射<br><code>docker run --restart=always --name auto_testing_v1 -d -p 8360:8360 -p 27018:27017 -p 9002:9001 auto_testing/ubuntu:v1 supervisord -n -c /etc/supervisord.conf</code></p><p><code>docker run --restart=always --privileged --name auto_testing \-d -p 8360:8360 -p 27018:27017 -p 9002:9001 \ubuntu/auto_testing:1.0 /bin/bash \-c &quot;while true;do echo hello world; sleep;done&quot;</code></p><p><code>docker run --restart=always --privileged --name nginx-test-1 \-d -p 80:80 nginx /bin/bash \-c &quot;while true;do echo hello world; sleep;done&quot;-v /pengzhiyang/nginx/conf.d:/etc/nginx/conf.d \</code></p><p>安装supervisor<br><code>yum install python-setuptools</code></p><p>生成supervisor配置文件模板</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">easy_install supervisor</span><br><span class="line">echo_supervisord_conf &gt; &#x2F;etc&#x2F;supervisord.conf</span><br></pre></td></tr></table></figure><p>使用配置文件启用supervisor<br><code>supervisord -c /etc/supervisord.conf</code></p><p>查看运行进程<br><code>supervisorctl status</code></p><p>停用supervisor<br><code>supervisorctl shutdown</code></p><p>#auto_testing 容器已部署的模块</p><ol><li>系统ubuntu</li><li>git</li><li>node</li><li>mongo<br>安装路径：<code>/projects/mongodb</code></li></ol><p>配置环境变量<br><code>vi /etc/profile</code><br>末行位置新增</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MONGODB_HOME&#x3D;&#x2F;projects&#x2F;mongodb</span><br><span class="line">export PATH&#x3D;&#x2F;projects&#x2F;mongodb&#x2F;bin:$PATH</span><br></pre></td></tr></table></figure><p><code>vi /etc/rc.local</code><br>配置开机启动服务(后台运行)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;projects&#x2F;mongodb&#x2F;bin&#x2F;mongod \</span><br><span class="line">--fork --port 27017 \</span><br><span class="line">--dbpath&#x3D;&#x2F;projects&#x2F;mongodb&#x2F;db \</span><br><span class="line">--logpath&#x3D;&#x2F;projects&#x2F;mongodb&#x2F;logs&#x2F;mongodb.log --logappend</span><br></pre></td></tr></table></figure><p>取消占用<br><code>rm -rf /projects/mongodb/db/mongod.lock</code></p><p>查看进程占用<br><code>netstat -ntpl</code></p><p>强制杀掉占用进程<br><code>kill -s 9 [pid]</code></p><ol start="5"><li>supervisor 进程控制管理</li></ol><h2 id="docker里安装ubuntu，ubuntu里再安装docker"><a href="#docker里安装ubuntu，ubuntu里再安装docker" class="headerlink" title="docker里安装ubuntu，ubuntu里再安装docker"></a>docker里安装ubuntu，ubuntu里再安装docker</h2><ol><li><code>docker pull ubuntu</code></li><li><code>docker run -it -d --privileged --name xxx ubuntu</code></li><li><code>docker exec -it xxx /bin/bash</code></li><li><code>apt-get update</code></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">apt-get -y install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common \</span><br><span class="line">    net-tools \</span><br><span class="line">    iptables</span><br></pre></td></tr></table></figure></li><li><code>curl -fsSL get.docker.com -o get-docker.sh</code></li><li><code>sh get-docker.sh --mirror Aliyun</code></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;dockerfile-和-docker-compose-的关系&quot;&gt;&lt;a href=&quot;#dockerfile-和-docker-compose-的关系&quot; class=&quot;headerlink&quot; title=&quot;dockerfile 和 docker-compose 的关
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>React 一些概念</title>
    <link href="https://h5m1007.github.io/2019/06/12/learn-from-react/"/>
    <id>https://h5m1007.github.io/2019/06/12/learn-from-react/</id>
    <published>2019-06-12T02:42:28.000Z</published>
    <updated>2020-05-28T09:56:40.204Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HOC"><a href="#HOC" class="headerlink" title="HOC"></a>HOC</h2><ul><li>一种模式，HOC本身为纯函数，没有任何副作用。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withOperation</span>(<span class="params">wrappedComponent, <span class="regexp">/*els*/</span></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        &lt;wrappedComponent /&gt;</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要直接修改其传入的组件，内部使用并返回新的 class 包裹下传入的组件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withOperation</span>(<span class="params">wrappedComponent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">wrappedComponent</span> /&gt;</span></span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h2><ul><li>使用时机：当相同的 props 输入，得到相同的渲染结果时使用；</li><li>实现方式：通过记忆组件渲染结果的方式来提高组件的性能表现；</li><li>表现：跳过渲染组件的操作并直接复用最近一次渲染结果；</li></ul><h2 id="虚拟-Dom-vdom-提高性能"><a href="#虚拟-Dom-vdom-提高性能" class="headerlink" title="虚拟 Dom (vdom) 提高性能"></a>虚拟 Dom (vdom) 提高性能</h2><ul><li>vdom 相当于是 JS 与 真实 Dom 之间的一层缓存，利用 Dom Diff 算法规避了一些没必要的 Dom 操作，从而提高了性能；</li><li>用 JavaScript 对象结构来表示 Dom 树的结构，用这棵树来构建一个真正的 Dom 树，插入文档中。</li><li>当状态变更时，重新构建一棵新的对象树，对比新旧两棵树的差异，记录差异构建真正的 Dom 树，从而更新视图；</li></ul><h2 id="Dom-Diff-原理"><a href="#Dom-Diff-原理" class="headerlink" title="Dom Diff 原理"></a>Dom Diff 原理</h2><ul><li>把树形结构按层级分解，只比较同级元素；</li><li>给列表结构的每个单元添加唯一的 key 属性，方便比较；<br>  diff 通过对比节点的 tag 和 key 是否为同一节点<br>  减少渲染次数，提高性能</li><li>React 只匹配相同 Class 的 Component；</li><li>合并操作，当 Component 调用 setState 方法时，React 会标记为 Dirty，到每个事件循环结束后，React 会检查每个标记为 Dirty 的 Component，并重新绘制；</li><li>选择性子树渲染，开发者可重写 shouldComponentUpdate 来提高 Diff 性能；<br>  当状态变更时，整个组件树都会发生重渲染，重定义 shouldComponentUpdate 的判断，可避免没必要的渲染<br>  采用 PureComponent、React.memo 隐式实现浅比较的 shouldComponentUpdate</li></ul><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><ul><li>Redux<ul><li>Store：存放数据如同一个容器，每个应用有且只有一个 Store；</li><li>State：数据对象，在特定时间点对 Store 的数据生成快照，在这样时间点下数据集合为 state；</li><li>Action：用户访问 View，View 发起 Action，dispatch 接受 Action 传入 State，调用 Store 的 Reducer 对 State 操作，返回新的 State，View 更新；</li><li>Reducer：接收 Action 及 State 做为参数传入，处理 State 并返回新的 State；</li><li>Dispatch：View 只能通过 Dispatch 派发 Action；</li></ul></li><li>react-redux<ul><li>Provider：封装整个应用，通过 Connect 模块传递 Store；</li><li>Connect：1. 连接 React 与 Redux，通过 Provider 提供的 Store，经 store.getState() 来获取 Store Tree 的 state；2. 包装原组件，以 Props 方式传入原组件内部，传入 mapStateToProps/mapDispatchToProps 与原有的 Props 合并；3. 监听 Store Tree 的变化，判断更新前后的 State，是否调用了 <code>this.setState()</code>，从而重渲染；</li><li>mapStateToProps：订阅 Store 的更新；</li><li>mapDispatchToProps：改变 Store；</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;HOC&quot;&gt;&lt;a href=&quot;#HOC&quot; class=&quot;headerlink&quot; title=&quot;HOC&quot;&gt;&lt;/a&gt;HOC&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;一种模式，HOC本身为纯函数，没有任何副作用。&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>VueJS 一些概念</title>
    <link href="https://h5m1007.github.io/2019/06/10/learn-from-vue/"/>
    <id>https://h5m1007.github.io/2019/06/10/learn-from-vue/</id>
    <published>2019-06-10T07:20:30.000Z</published>
    <updated>2020-05-18T03:28:22.560Z</updated>
    
    <content type="html"><![CDATA[<h2 id="生命周期函数"><a href="#生命周期函数" class="headerlink" title="生命周期函数"></a>生命周期函数</h2><p>8个周期阶段，分别为：创建前/后、载入前/后、更新前/后、销毁前/后。</p><ul><li>beforeCreate: 还未有 Vue 实例的挂载对象 el；</li><li>created: 已有数据观测、属性/方法运算、watch/事件监听回调；</li><li>beforeMount: 已初始化 Vue 实例对象的 $el, data，还是虚拟 Dom 节点；</li><li>mounted: 已挂载 Vue 实例对象，虚拟 Dom 代替了文档的 el 位置；</li><li>beforeUpdate/updated: 当 data 发生变化，会调用 beforeUpdate/updated 两个周期函数；</li><li>beforeDestroy/destroyed: 当调用 destroy 方法后，data 的变化不再调用所有的周期函数，此时的 Vue 已解除事件监听以及对 Dom 的绑定，但 Dom 结构依旧存在；</li></ul><h2 id="Vue-的优势"><a href="#Vue-的优势" class="headerlink" title="Vue 的优势"></a>Vue 的优势</h2><ul><li>低耦合：View 可独立于 Model 变化和修改，一个 ViewModel 可绑定到不同的 View 上，View 变化时 Model 可不变，Model 变化时 View 也可不变；</li><li>可重用性：可把一些视图逻辑写在 ViewModel，让更多地 View 去重用这些视图逻辑；</li><li>独立开发：开发者可更专注于业务逻辑和数据的开发；</li><li>可测试：针对 ViewModel 编写测试用例；</li></ul><h2 id="Vue-双向绑定原理"><a href="#Vue-双向绑定原理" class="headerlink" title="Vue 双向绑定原理"></a>Vue 双向绑定原理</h2><ul><li>VueJS采用数据劫持结合订阅者-发布者模式的方式，通过 <code>Object.definedProperty</code> 对对象各个属性的 <code>setter</code>、<code>getter</code> 进行代理劫持，当数据变动时，发布消息给订阅者，并触发相应的监听回调。</li></ul><h2 id="Vuex-的原理"><a href="#Vuex-的原理" class="headerlink" title="Vuex 的原理"></a>Vuex 的原理</h2><ul><li>Vuex 仅作为 Vue 的一个插件存在，不像 Redux 等状态管理库能用于其它框架之上，而 Vuex 只能在 Vue 上使用，最大程度上是因为其高度依赖于 Vue 的 Computed 依赖监测系统以及其插件系统。</li><li>Vuex 的思想诞生于 Flux，而其实现方式又完完全全使用 Vue 的响应式设计，依赖监听、收集都属于 Vue 对对象各个属性的代理劫持。</li><li>Vuex 的 store 其本质是没有 template 的隐藏着的 Vue 组件。</li></ul><h2 id="Vuex-核心属性"><a href="#Vuex-核心属性" class="headerlink" title="Vuex 核心属性"></a>Vuex 核心属性</h2><p>共同5个属性，分别为 state、getter、mutation、action、module。</p><h3 id="Vuex-的-store-特性"><a href="#Vuex-的-store-特性" class="headerlink" title="Vuex 的 store 特性"></a>Vuex 的 store 特性</h3><ul><li>store 如同一个仓库，里面有多个对象，其中 state 是数据源的存放地，类似于 Vue 对象的 data；</li><li>存放在 state 的数据是响应式的，一个组件往 store 取数据，store 里的数据一旦变化，依赖这数据的组件也会随之更新；</li><li>store 是通过 mapState 把 state 和 getters 映射到当前组件的 computed 属性上；</li></ul><h3 id="Vuex-的-getter-特性"><a href="#Vuex-的-getter-特性" class="headerlink" title="Vuex 的 getter 特性"></a>Vuex 的 getter 特性</h3><ul><li>getter 对 state 进行计算操作，是 store 的计算属性；</li><li>组件可以有 getter 作为计算属性，getter 也可供多个组件复用；</li><li>如果一个状态仅用于一个组件，则可不需要 getter；</li></ul><h3 id="Vuex-的-mutation-特性"><a href="#Vuex-的-mutation-特性" class="headerlink" title="Vuex 的 mutation 特性"></a>Vuex 的 mutation 特性</h3><ul><li>执行的是同步操作；</li><li>是修改 state 的唯一途径；</li><li>可直接变更 state 状态；</li></ul><h3 id="Vuex-的-action-特性"><a href="#Vuex-的-action-特性" class="headerlink" title="Vuex 的 action 特性"></a>Vuex 的 action 特性</h3><ul><li>action 类似于 mutation，但提交的是 mutation，而不是直接修改 state；</li><li>可包含任意多个异步操作；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;生命周期函数&quot;&gt;&lt;a href=&quot;#生命周期函数&quot; class=&quot;headerlink&quot; title=&quot;生命周期函数&quot;&gt;&lt;/a&gt;生命周期函数&lt;/h2&gt;&lt;p&gt;8个周期阶段，分别为：创建前/后、载入前/后、更新前/后、销毁前/后。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;befor
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>node支持ES6语法配置</title>
    <link href="https://h5m1007.github.io/2018/10/15/node_support_es6/"/>
    <id>https://h5m1007.github.io/2018/10/15/node_support_es6/</id>
    <published>2018-10-15T03:31:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>让node支持ES6语法的配置方案</p><h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&quot;babel-cli&quot;: &quot;^6.26.0&quot;,</span><br><span class="line">&quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,</span><br><span class="line">&quot;babel-preset-es2015&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;babel-preset-stage-0&quot;: &quot;^6.24.1&quot;,</span><br><span class="line">&quot;babel-runtime&quot;: &quot;^6.26.0&quot;</span><br></pre></td></tr></table></figure><h2 id="babelrc"><a href="#babelrc" class="headerlink" title=".babelrc"></a>.babelrc</h2><ul><li>根目录添加 babel 配置文件 .babelrc</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;presets&quot;: [</span><br><span class="line">        &quot;es2015&quot;,</span><br><span class="line">        &quot;stage-0&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;plugins&quot;: [</span><br><span class="line">        &quot;transform-runtime&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="entry-js"><a href="#entry-js" class="headerlink" title="entry.js"></a>entry.js</h2><ul><li>在入口文件里引入</li></ul><p><code>require(&#39;babel-core/register&#39;);</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;让node支持ES6语法的配置方案&lt;/p&gt;
&lt;h2 id=&quot;package-json&quot;&gt;&lt;a href=&quot;#package-json&quot; class=&quot;headerlink&quot; title=&quot;package.json&quot;&gt;&lt;/a&gt;package.json&lt;/h2&gt;&lt;figure 
      
    
    </summary>
    
    
      <category term="node" scheme="https://h5m1007.github.io/categories/node/"/>
    
    
      <category term="node es6" scheme="https://h5m1007.github.io/tags/node-es6/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录八</title>
    <link href="https://h5m1007.github.io/2016/11/18/learn-from-nodejs/"/>
    <id>https://h5m1007.github.io/2016/11/18/learn-from-nodejs/</id>
    <published>2016-11-18T10:17:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="Socket-IO"><a href="#Socket-IO" class="headerlink" title="Socket.IO"></a>Socket.IO</h2><p>基于WebSocket出现的问题，Socket.IO在解决问题的同时保留了其API，也提供了良好的灵活性  </p><h3 id="兼容性高"><a href="#兼容性高" class="headerlink" title="兼容性高"></a>兼容性高</h3><p>Socket.IO的消息传递是<strong>基于传输</strong>的，并非全依靠WebSocket，可在大部分浏览器和设备上运行，包括IE6到IOS  </p><h3 id="可靠事件机制"><a href="#可靠事件机制" class="headerlink" title="可靠事件机制"></a>可靠事件机制</h3><p>提供对<strong>超时</strong>支持，监听 <code>connect</code> 和 <code>disconnect</code> 事件而不是 <code>open</code> 和 <code>close</code> 事件  </p><h3 id="Web通信方式"><a href="#Web通信方式" class="headerlink" title="Web通信方式"></a>Web通信方式</h3><p>典型通信方式经HTTP收发资源，而<strong>实时</strong>Web世界中，都是基于<strong>事件传输</strong>的  </p><p>Socket.IO通过分发 (<code>emit</code>) 和 监听 (<code>listen</code>) 来进行JSON数据收发  </p><p>WebSocket.IO方式  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    ws.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">        socket.on(&#39;message&#39;, function(msg)&#123;</span><br><span class="line">            &#x2F;&#x2F; deal with msg</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>Socket.IO方式  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    io.sockets.on(&#39;connection&#39;, function(socket)&#123;</span><br><span class="line">        socket.on(&#39;message&#39;, function(msg)&#123;</span><br><span class="line">            &#x2F;&#x2F; deal with msg</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>命名空间即多路传输，socket.io对同样的资源进行<strong>频道划分</strong>，并将数据传输给对应的回调，且允许监听多个命名空间的 <code>connection</code> 事件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    io.sockets.on(&#39;connection&#39;);</span><br><span class="line">    io.of(&#39;&#x2F;some&#x2F;namespace&#39;).on(&#39;connection&#39;);</span><br><span class="line">    io.of(&#39;&#x2F;some&#x2F;other&#x2F;namespace&#39;).on(&#39;connection&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="实现实时聊天"><a href="#实现实时聊天" class="headerlink" title="实现实时聊天"></a>实现实时聊天</h3><ol><li>引入express和socket.io模块声明为 <code>sio</code></li><li>express创建服务并将返回对象 <code>app</code> 给 <code>sio</code> 监听</li><li>调用监听返回的全局对象 <code>io</code> 的 <code>sockets</code> 属性</li><li>用来监听 <code>connection</code>，回调带socket参数</li><li>该参数在连接后，用来监听客户端分发的 <code>join</code> 用户加入的事件</li><li>监听客户端分发的数据事件 <code>text</code></li><li>在 <code>join</code> 事件回调中，<code>broadcast.emit()</code> 给<strong>所有用户</strong>分发 <code>annoucement</code> 事件</li><li>在客户端调用全局对象的 <code>connect()</code> 方法</li><li>调用返回的对象 <code>socket</code> ，用来监听 <code>connect</code> 事件</li><li>监听后回调中，使用 <code>socket</code> 来分发 <code>emit</code> 事件和给回调的参数</li><li>当客户端有用户加入时，在 <code>connect</code> 回调中分发事件 <code>join</code></li><li>监听服务端分发的 <code>annoucement</code> 事件</li><li>当用户提交消息时，分发 <code>text</code> 事件和给回调的参数</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;Socket-IO&quot;&gt;&lt;a href=&quot;#Socket-IO&quot; class=&quot;headerlink&quot; title=&quot;Socket.IO&quot;&gt;&lt;/a&gt;Socket.IO&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
      <category term="nodejs javascript" scheme="https://h5m1007.github.io/categories/nodejs-javascript/"/>
    
    
      <category term="nodejs express socket.io" scheme="https://h5m1007.github.io/tags/nodejs-express-socket-io/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序 需要知道的事</title>
    <link href="https://h5m1007.github.io/2016/11/17/weixin_small_app/"/>
    <id>https://h5m1007.github.io/2016/11/17/weixin_small_app/</id>
    <published>2016-11-17T05:55:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。</p><h2 id="什么是微信小程序"><a href="#什么是微信小程序" class="headerlink" title="什么是微信小程序"></a>什么是微信小程序</h2><p>微信小程序是一种不需要下载安装即可使用的应用  </p><p>实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用  </p><p>体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题  </p><p>应用将无处不在，随时可用，但又无需安装卸载  </p><h3 id="小程序和公众号内嵌H5有什么区别"><a href="#小程序和公众号内嵌H5有什么区别" class="headerlink" title="小程序和公众号内嵌H5有什么区别"></a>小程序和公众号内嵌H5有什么区别</h3><ol><li><p>一般公众号会在菜单底部提供功能引导入口，引导用户到H5页面，但H5体验与Native App差距还是比较大的，而微信小程序提供丰富框架组件和API接口，在这些组件和接口的帮助下，开发在微信的小程序基本保持与Native App一样的流畅度，极大提高了用户体验  </p></li><li><p>微信小程序可以理解为RN即React Native，H5写的程序然后以Native App方式运行，其原理都是用JS调用底层Native组件  </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;微信小程序是一种不需要下载安装即可使用的应用，它实现了应用“触手可及”的梦想，用户扫一扫或者搜一下即可打开应用。也体现了“用完即走”的理念，用户不用关心是否安装太多应用的问题。应用将无处不在，随时可用，但又无需安装卸载。&lt;/p&gt;
&lt;h2 id=&quot;什么是微信小程序&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="weixin H5 js react" scheme="https://h5m1007.github.io/categories/weixin-H5-js-react/"/>
    
    
      <category term="weixin H5 js react" scheme="https://h5m1007.github.io/tags/weixin-H5-js-react/"/>
    
  </entry>
  
  <entry>
    <title>react 回忆录二</title>
    <link href="https://h5m1007.github.io/2016/11/11/learn-from-react/"/>
    <id>https://h5m1007.github.io/2016/11/11/learn-from-react/</id>
    <published>2016-11-11T02:55:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>革命性创新 性能出众 代码逻辑灰常简单的 React</p><h2 id="什么是Redux"><a href="#什么是Redux" class="headerlink" title="什么是Redux"></a>什么是Redux</h2><p>本身为一种架构，将Flux与函数式编程结合在一起</p><h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ol><li>用户使用方式复杂</li><li><strong>不同身份</strong>用户拥有<em>不同使用方式</em></li><li>多用户间可<strong>协作</strong></li><li>与<em>服务器<em>大量交互，亦或使用</em>WebSocket</em></li><li>View需从<strong>多个来源</strong>获取数据</li><li>某组件的<em>状态</em>需<strong>共享</strong></li><li>某状态需在<em>任何地方</em>都可拿到</li><li>单个组件需改变<strong>全局状态</strong></li><li>一个组件需改变<em>另一个</em>组件状态</li></ol><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><ul><li>Web App是一个状态机，视图和状态是一一对应的</li><li>所有状态保存至一个对象里面</li></ul><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><h3 id="Store"><a href="#Store" class="headerlink" title="Store"></a>Store</h3><p>用来保存所有数据的容器，整个App只能有一个，由 <code>createStore(fn)</code> 来生成，接受一个Reducer函数作为参数，即后面所说到的Reducer，一个用来根据Action的不同而生成此刻的State快照的函数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;;</span><br><span class="line">const store &#x3D; createStore(fn);</span><br></pre></td></tr></table></figure><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>当想从Store里获得<strong>某时间点</strong>的数据，可对Store生成快照，而这种时间点下的数据集合称为<strong>State</strong>  </p><p>而state储存在一棵对象树state tree中，且这棵树只存在于唯一的store中  </p><p>当前时刻的State可由 <code>store.getState()</code> 获得  </p><p>State与View一一对应，即State相同View就相同  </p><p>State本身是<strong>只读</strong>的，而改变它的方法就是触发action  </p><h3 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h3><p>本身为一个描述已发生事件的对象，接受的属性有<strong>type</strong>(必选 表示Action名称)和其它自定义属性  </p><p>因State的变化需由View来导致，而Action为View发出的<strong>通知</strong>，告诉State应有所变化了  </p><p>Action描述当前所发生的事情，它是改变State的唯一办法，它会运送数据至Store  </p><p>Action是把数据从应用传到store的有效载荷，是store数据的唯一来源，一般经 <code>store.dispatch()</code> 传action到store  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const action &#x3D; &#123;</span><br><span class="line">    type: &#39;ADD_TODO&#39;, &#x2F;&#x2F; 名称</span><br><span class="line">    payload: &#39;Learn Redux&#39; &#x2F;&#x2F; 携带信息</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可封装一个生成Action的函数，只需提供Action的名称即可  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Action Creator</span><br><span class="line">const ADD_TODO &#x3D; &#39;添加 TODO&#39;;</span><br><span class="line">function addTodo(text)&#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        tyep: ADD_TODO,</span><br><span class="line">        text</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const action &#x3D; addTodo(&#39;Learn Redux&#39;);</span><br></pre></td></tr></table></figure><h4 id="dispatch"><a href="#dispatch" class="headerlink" title="dispatch()"></a>dispatch()</h4><p><code>store.dispatch()</code>  是View发出Action的唯一办法，接受Action对象作为参数  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; createStore &#125; from &#39;redux&#39;;</span><br><span class="line">const store &#x3D; createStore(fn);</span><br><span class="line">store.dispatch(addTodo(&#39;Learn redux&#39;));</span><br></pre></td></tr></table></figure><h4 id="Reducer"><a href="#Reducer" class="headerlink" title="Reducer"></a>Reducer</h4><p>当Store收到Action时，Store需给出一个新的State快照，从而View才会变化，整个一个过程称为Reducer，它接受Action和此刻的State快照作为参数，并返回一个新的State  </p><p>即 <code>(previousState, action) =&gt; newState</code>  </p><p>简单来说，就是为了描述action是如何改变state tree的  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const defaultState &#x3D; 0;</span><br><span class="line">const reducer &#x3D; (state &#x3D; defaultState, action) &#x3D;&gt; &#123;</span><br><span class="line">    switch (action.type) &#123;</span><br><span class="line">        case &#39;ADD&#39;:</span><br><span class="line">            return state + action.payload;</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">const state &#x3D; reducer(1, &#123;</span><br><span class="line">    type: &#39;ADD&#39;,</span><br><span class="line">    payload: 2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里的Reducer需手动调用，而当把它作为参数传入 <code>createStore(reducer)</code>，可实现每当 <code>store.dispatch()</code> 发来一个新Action时，自动调用Reducer并得到新State  </p><h5 id="Reducer拆分"><a href="#Reducer拆分" class="headerlink" title="Reducer拆分"></a>Reducer拆分</h5><p>面对所有reducers最终只会生成唯一的state对象，这意味着该state包含所有数据，导致本身体积十分庞大，进而有了对reducers的拆分  </p><p>拆分后，单独的reducer可独立操作state tree中某个state，可控制它们被调用的顺序，传入附加数据，编写可复用的reducer来处理一些通用任务  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">const chatReducer &#x3D; (state &#x3D; defaultState, action &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">     * 假设 action &#x3D; &#123;type: &#39;add&#39;, payload: &#39;str&#39;&#125;;</span><br><span class="line">     * 则声明 const &#123; type, payload &#125; &#x3D; action;</span><br><span class="line">     * 调用type返回&#39;add&#39;，调用payload返回&#39;str&#39;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    const &#123; type, payload &#125; &#x3D; action; &#x2F;&#x2F; 解构赋值</span><br><span class="line">    switch(type)&#123;</span><br><span class="line">        case &#39;ADD_CHAT&#39;:</span><br><span class="line">            return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                    &#x2F;&#x2F; Object.assign(&#123;&#125;, &#123;&#125;, ...) 合并多个对象</span><br><span class="line">                    &#x2F;&#x2F; 遇相同属性时 位于后面的属性覆盖前面的</span><br><span class="line">                    chatLog: state.chatLog.concat(payload) &#x2F;&#x2F; str.concat(str) 拼接指定字符串</span><br><span class="line">                &#125;);</span><br><span class="line">        case &#39;CHANGE_STATUS&#39;:</span><br><span class="line">            return Object.assign(&#123;&#125;, state, &#123;</span><br><span class="line">                    statusMessage: payload</span><br><span class="line">                &#125;);</span><br><span class="line">        default:</span><br><span class="line">            return state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可看出上述代码，有两种Action分别改变State的两个属性  </p><ul><li>ADD_CHAT =&gt; chatLog属性</li><li>CHANGE_STATUS =&gt; statusMessage属性</li></ul><p>把上述各个reducer进行拆分  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主reducer</span><br><span class="line">const chatReducer &#x3D; (state &#x3D; defaultState, action &#x3D; &#123;&#125;) &#x3D;&gt; &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">        &#x2F;&#x2F; 子reducer</span><br><span class="line">        chatLog: chatLog(state.chatLog, action),</span><br><span class="line">        statusMessage: statusMessage(state.statusMessage, action)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个子reducer分别处理全局state中的一部分，各自的state参数都是不同的，分别对应它管理的那部分state数据  </p><p>再由 <code>combineReducers()</code> 来合并reducer成一个大的Reducer  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import &#123; combineReducers &#125; from &#39;redux&#39;;</span><br><span class="line">const chatReducer &#x3D; combineReducers(&#123;</span><br><span class="line">    chatLog,</span><br><span class="line">    statusMessage</span><br><span class="line">&#125;)</span><br><span class="line">export default todoApp;</span><br></pre></td></tr></table></figure><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h5><p>当一组actions为数组时，存储着多个Action对象，此时可调用 <code>actions.reduce(reducer, 0)</code> ，reducer作为参数，这样可实现同时处理一个actions数组的Action对象，并得到最终结果  </p><h4 id="subscribe"><a href="#subscribe" class="headerlink" title="subscribe()"></a>subscribe()</h4><p><code>store.subscribe(listener)</code>  Store设置监听函数，可实现一旦store的快照state发生变化后，就会自动执行这个函数  </p><p>用于把组件的render方法亦或setState方法作为listener监听对象，state变化的同时自动渲染View页面  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let unsubscribe &#x3D; store.subscribe(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(store.getState());</span><br><span class="line">&#125;);</span><br><span class="line">unsubscribe(); &#x2F;&#x2F;直接调用能解除监听</span><br></pre></td></tr></table></figure><h2 id="Redux工作流程"><a href="#Redux工作流程" class="headerlink" title="Redux工作流程"></a>Redux工作流程</h2><p><img src="http://img.blog.csdn.net/20151210233944838" alt="结构图1"></p><p><img src="http://img.blog.csdn.net/20151210234529139" alt="结构图2"></p><ol><li>用户与View交互发出Action</li><li><code>store.dispatch(Reducer(state, action))</code> store经 <code>store.dispatch()</code> 向View发送state，而Action和此刻state作为参数传入Reducer，Reducer处理后返回新的state，发送给View</li><li>一旦State有新变化，Store调用监听 <code>store.subscribe(listener)</code> ，侦听器listener可能是 <code>store.getState()</code> 获取此刻新state，亦或通知经组件state有变化渲染View</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;革命性创新 性能出众 代码逻辑灰常简单的 React&lt;/p&gt;
&lt;h2 id=&quot;什么是Redux&quot;&gt;&lt;a href=&quot;#什么是Redux&quot; class=&quot;headerlink&quot; title=&quot;什么是Redux&quot;&gt;&lt;/a&gt;什么是Redux&lt;/h2&gt;&lt;p&gt;本身为一种架构，将Flu
      
    
    </summary>
    
    
      <category term="react redux jsx" scheme="https://h5m1007.github.io/categories/react-redux-jsx/"/>
    
    
      <category term="react redux jsx" scheme="https://h5m1007.github.io/tags/react-redux-jsx/"/>
    
  </entry>
  
  <entry>
    <title>online resume record</title>
    <link href="https://h5m1007.github.io/2016/11/05/prepare-resume-record/"/>
    <id>https://h5m1007.github.io/2016/11/05/prepare-resume-record/</id>
    <published>2016-11-05T02:03:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>在线简历构建过程记录</p><h2 id="Jade"><a href="#Jade" class="headerlink" title="Jade"></a>Jade</h2><p>…占位</p><h3 id="include-amp-amp-extends"><a href="#include-amp-amp-extends" class="headerlink" title="include &amp;&amp; extends"></a>include &amp;&amp; extends</h3><ul><li><code>include</code>  引入页面补充部分，哪个位置缺某部分，包含进来作补充</li><li><code>extends</code>  先给出整体，再替换局部</li></ul><p>include应用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; index.jade</span><br><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">    include header</span><br><span class="line">    body</span><br><span class="line">        h1 welcome xxx</span><br><span class="line">        p content</span><br><span class="line">    include footer</span><br></pre></td></tr></table></figure><p>extends应用  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; layout.jade</span><br><span class="line">doctype html</span><br><span class="line">html</span><br><span class="line">    head</span><br><span class="line">        block title</span><br><span class="line">            title Default Title</span><br><span class="line">    body</span><br><span class="line">        block content</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; index.jade</span><br><span class="line">extends layout</span><br><span class="line">block title</span><br><span class="line">    title New Title</span><br><span class="line">block content</span><br><span class="line">    h1 new title</span><br><span class="line">    p new content</span><br></pre></td></tr></table></figure><h2 id="Gulp"><a href="#Gulp" class="headerlink" title="Gulp"></a>Gulp</h2><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><ul><li>gulp执行指定任务并回调  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    gulp.task(&#39;build&#39;, [&#39;task1&#39;, &#39;task2&#39;], function()&#123;</span><br><span class="line">        &#x2F;&#x2F; 只执行任务build</span><br><span class="line">        &#x2F;&#x2F; 同时会执行task1, task2</span><br><span class="line">        gulp.src(&#39;src&#39;) &#x2F;&#x2F; 将返回对象流</span><br><span class="line">            .pipe(plugin1());</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.task(&#39;task1&#39;, function()&#123;</span><br><span class="line">        gulp.src(&#39;src1&#39;)</span><br><span class="line">            .pipe(plugin1());</span><br><span class="line">    &#125;);</span><br><span class="line">    gulp.task(&#39;task2&#39;, [&#39;task1&#39;], function()&#123;</span><br><span class="line">        &#x2F;&#x2F; 可让task1执行完</span><br><span class="line">        &#x2F;&#x2F; 再执行task2</span><br><span class="line">        gulp.src(&#39;src2&#39;)</span><br><span class="line">            .pipe(plugin2());</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>gulp task</code> 命令行执行任务名，直接执行指定任务  </p><p><em>gulp.src()方法输入一个如匹配一个或多个文件的字符串，或者glob数组，然后返回一个可以传递给插件的数据流</em>  </p><p><code>pipe()</code> 把<strong>对象流</strong>对接在插件上，并让插件处理对象  </p><ul><li>Plugins</li></ul><p><code>gulp-load-plugins</code>  该插件自动按需(当需被调用时才加载)加载 <code>paskage.json</code> 中Gulp插件，并把它们附加在一个对象上  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var gulp &#x3D; require(&#39;gulp&#39;),</span><br><span class="line">        gulpLoadPlugins &#x3D; require(&#39;gulp-load-plugins&#39;),</span><br><span class="line">        plugins &#x3D; gulpLoadPlugins();</span><br><span class="line">    gulp.task(&#39;js&#39;, function () &#123;</span><br><span class="line">       return gulp.src(&#39;js&#x2F;*.js&#39;)</span><br><span class="line">          .pipe(plugins.jshint())</span><br><span class="line">          .pipe(plugins.jshint.reporter(&#39;default&#39;))</span><br><span class="line">          .pipe(plugins.uglify())</span><br><span class="line">          .pipe(plugins.concat(&#39;app.js&#39;))</span><br><span class="line">          .pipe(gulp.dest(&#39;build&#39;)) &#x2F;&#x2F; 指定输出目录</span><br><span class="line">          .pipe(gulp.livereload()); &#x2F;&#x2F; 文件被修改自动加载刷新网页</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>Watch</li></ul><p><code>gulp.watch()</code>  监听文件修改状态，在文件被改动时执行一个或多个任务  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var watcher &#x3D; gulp.task(&#39;watch&#39;, function (e) &#123;</span><br><span class="line">       gulp.watch(&#39;xxx.scss&#39;, [&#39;buildSass&#39;]);</span><br><span class="line">       console.log(&#39;Event type: &#39; + e.type); &#x2F;&#x2F; added, changed, or deleted</span><br><span class="line">       console.log(&#39;Event path: &#39; + e.path); &#x2F;&#x2F; The path of the modified file</span><br><span class="line">    &#125;);</span><br><span class="line">    watcher.on(&#39;change&#39;, function()&#123;&#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><h3 id="Gulp-amp-amp-Grunt"><a href="#Gulp-amp-amp-Grunt" class="headerlink" title="Gulp &amp;&amp; Grunt"></a>Gulp &amp;&amp; Grunt</h3><h4 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h4><ol><li><p>Gulp和Grunt的工作方式很不一样。Grunt不使用数据流，而是使用文件，对文件执行单个任务然后保存到新的文件中，每个任务都会重复执行所有进程，文件系统频繁的处理任务会导致Grunt的运行速度比Gulp慢  </p></li><li><p>Grunt任务拥有大量的配置，会引用大量你实际上并不需要的对象属性，但是Gulp里同样的任务也许只有几行而已  </p></li><li><p>Grunt比Gulp更加频繁地操作文件系统，所以使用数据流的Gulp总是比Grunt快。对于一个小的LESS文件，gulpfile.js通常需要6ms，而gruntfile.js则需要大概50ms——慢8倍多  </p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在线简历构建过程记录&lt;/p&gt;
&lt;h2 id=&quot;Jade&quot;&gt;&lt;a href=&quot;#Jade&quot; class=&quot;headerlink&quot; title=&quot;Jade&quot;&gt;&lt;/a&gt;Jade&lt;/h2&gt;&lt;p&gt;…占位&lt;/p&gt;
&lt;h3 id=&quot;include-amp-amp-extends&quot;&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="javascript gulp jade" scheme="https://h5m1007.github.io/categories/javascript-gulp-jade/"/>
    
    
      <category term="javascript gulp jade" scheme="https://h5m1007.github.io/tags/javascript-gulp-jade/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录七</title>
    <link href="https://h5m1007.github.io/2016/11/01/learn-from-nodejs/"/>
    <id>https://h5m1007.github.io/2016/11/01/learn-from-nodejs/</id>
    <published>2016-11-01T06:03:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="websocket"><a href="#websocket" class="headerlink" title="websocket"></a>websocket</h2><ul><li><p>websocket是一个协议，类似于TCP/IP、HTTP协议，但它们需要有socket辅助来提供给外部调用的API，而websocket本身就有一个 <strong>WebSocket API</strong>  </p></li><li><p>使用socket这样的网络协议APIs不会符合原始安全模型，而websocket则不会，它提供给H5应用TCP的方式却不会削弱网络安全且还能同时拥有现代API  </p></li><li><p>websocket相对于http协议，拟补了http不适合<strong>实时通信</strong>的缺陷，websocket以异步双向通信模式，通过传输层协议使其更急有灵活性  </p></li><li><p>websocket协议能够让客户端和远程服务器端通过web建立<strong>全双工通信</strong>，且支持二进制字符串和文本字符串，协议包含打开<strong>握手</strong>之后的基本消息框架  </p></li></ul><h3 id="websocket-API"><a href="#websocket-API" class="headerlink" title="websocket API"></a>websocket API</h3><ul><li><p>websocket的接口，可通过它来建立<strong>全双工通道</strong>来收发消息，当连接远程服务器，只需创建一个websocket实体，即实例化一个实例，并传入类似 “ws://<a href="http://www.xxx.com&quot;" target="_blank" rel="noopener">www.xxx.com&quot;</a> 的URL  </p></li><li><p>客户端和服务端在开始握手的期间，http会升级至websocket，这样建立了连接，其底层都是TCP协议  </p></li><li><p>websocket api 是<strong>纯事件驱动</strong>的，即可使用异步事件监听来连接其整个生命周期的每个阶段  </p></li></ul><p><code>onopen()</code><br>一旦服务器响应websocket连接请求后触发open事件，这意味着协议握手结束，websocket已准备好收发数据，也就是说现在可确定服务端已经处理好了建立连接的请求，同意和你的应用通信了  </p><p><code>onmessage()</code><br>一旦websocket收到数据后触发message事件  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    ws.onmessage &#x3D; function(e)&#123;</span><br><span class="line">        if(e.data)&#123;</span><br><span class="line">            console.log(e.data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>onerror</code><br>连接失败或其它操作引起错误等都会触发error事件，从而导致连接关闭  </p><p><code>onclose</code><br>连接关闭时触发close事件，之后客户端和服务器就不能再通信了  </p><ul><li><p>建立其全双工连接，服务器发送数据或资源给客户端，它能自动发送状态改变的<strong>数据和通知</strong>，从而我们无须为了状态的更新而去轮询server，只要在客户端进行监听即可  </p></li><li><p>websocket对象的实例有两个方法：<code>send()</code>  <code>close()</code>  </p></li></ul><p><code>send()</code><br>提供给服务端和客户端相互发送消息的方法，但需要在 <code>onopen</code> 连接完全建立了才能使用该方法  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    ws.onopen &#x3D; function(e)&#123;</span><br><span class="line">        ws.send(str);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>close()</code><br>手动关闭连接，一旦使用该方法，将不能再发送数据  </p><p><code>ws.close(status, &quot;reason&quot;)</code>  可选两参数，状态码和关闭原因  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    ws.close(</span><br><span class="line">        1000,</span><br><span class="line">        &quot;Closing normally!&quot;</span><br><span class="line">    )</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>websocket对象有三个属性：readyState、bufferedAmount、Protocol</li></ul><p><code>ws.readyState</code><br>该属性来表示连接状态，会随着连接状态变化而变化  </p><table><thead><tr><th align="left">属性</th><th align="right">值</th><th align="center">状态</th></tr></thead><tbody><tr><td align="left">WebSocket.CONNECTING</td><td align="right">0</td><td align="center">连接正进行但未建立</td></tr><tr><td align="left">WebSocket.OPEN</td><td align="right">1</td><td align="center">连接已建立可发送消息</td></tr><tr><td align="left">WebSocket.CLOSING</td><td align="right">2</td><td align="center">正关闭握手</td></tr><tr><td align="left">WebSocket.CLOSED</td><td align="right">3</td><td align="center">连接已关闭或不能打开</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    if(ws.readyState &#x3D;&#x3D;&#x3D; WebSocket.OPEN)&#123;</span><br><span class="line">        &#x2F;&#x2F; 待连接已建立</span><br><span class="line">        ws.send(data);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>ws.bufferedAmount</code><br><code>send()</code>发送的数据不会立即传输，而是被浏览器缓存每次应用流出的数据，bufferedAmount可用来检查每次流出的数据大小，而这些数据已进入队列但未被传输  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;echo.websocket.org&quot;),</span><br><span class="line">        maxData &#x3D; 10240;</span><br><span class="line">    ws.onopen &#x3D; function()&#123;</span><br><span class="line">        setInterval(function()&#123;</span><br><span class="line">            if(ws.bufferedAmount &lt; maxData)&#123;</span><br><span class="line">                ws.send()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,1000);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>ws.protocol</code><br>返回当前使用的websocket协议，由服务器提供  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;websocket&quot;&gt;&lt;a href=&quot;#websocket&quot; class=&quot;headerlink&quot; title=&quot;websocket&quot;&gt;&lt;/a&gt;websocket&lt;/h2&gt;&lt;u
      
    
    </summary>
    
    
      <category term="nodejs javascript" scheme="https://h5m1007.github.io/categories/nodejs-javascript/"/>
    
    
      <category term="nodejs express websocket" scheme="https://h5m1007.github.io/tags/nodejs-express-websocket/"/>
    
  </entry>
  
  <entry>
    <title>react 回忆录一</title>
    <link href="https://h5m1007.github.io/2016/11/01/learn-from-react/"/>
    <id>https://h5m1007.github.io/2016/11/01/learn-from-react/</id>
    <published>2016-11-01T02:55:00.000Z</published>
    <updated>2020-04-30T06:38:46.782Z</updated>
    
    <content type="html"><![CDATA[<p>革命性创新 性能出众 代码逻辑灰常简单的 React</p><h2 id="什么是React"><a href="#什么是React" class="headerlink" title="什么是React"></a>什么是React</h2><p>React 起源于Facebook的内部项目，项目本身也越滚越大，从最早的UI引擎变成了一整套前后端通吃的 Web App 解决方案</p><h2 id="怎么玩"><a href="#怎么玩" class="headerlink" title="怎么玩"></a>怎么玩</h2><p>引入三大法宝： <code>react.js</code>、<code>react-dom.js</code>、<code>browser.js</code>  </p><p><code>react.js</code> 是 React 的核心库<br><code>react-dom.js</code> 是提供与 DOM 相关的功能<br><code>browser.js</code> 的作用是将 JSX 语法转为 JavaScript 语法  </p><ul><li>JSX<br>允许 HTML 与 JavaScript 的混写，遇到 HTML 标签（以 &lt; 开头），就用 HTML 规则解析；遇到代码块（以 { 开头），就用 JavaScript 规则解析</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- ... --&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;example&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;script type&#x3D;&quot;text&#x2F;babel&quot;&gt;</span><br><span class="line">    var names &#x3D; [&#39;Leon&#39;, &#39;Leo&#39;],</span><br><span class="line">        arr &#x3D; [</span><br><span class="line">            &lt;h1&gt;React is awesome&lt;&#x2F;h1&gt;,</span><br><span class="line">            &lt;h2&gt;good app!&lt;&#x2F;h2&gt;</span><br><span class="line">        ],</span><br><span class="line">        Msg &#x3D; React.createClass(&#123;</span><br><span class="line">            render: function()&#123;</span><br><span class="line">                return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    ReactDOM.render(</span><br><span class="line">        &#x2F;&#x2F; &lt;h1&gt;Hello world!&lt;&#x2F;h1&gt;,</span><br><span class="line">        &#x2F;&#x2F; &lt;div&gt;</span><br><span class="line">        &#x2F;&#x2F;  &#123;</span><br><span class="line">        &#x2F;&#x2F;      names.map(function(name)&#123;</span><br><span class="line">        &#x2F;&#x2F;          return &lt;div&gt;Hello, &#123;name&#125;!&lt;&#x2F;div&gt;</span><br><span class="line">        &#x2F;&#x2F;      &#125;)</span><br><span class="line">        &#x2F;&#x2F;  &#125;</span><br><span class="line">        &#x2F;&#x2F; &lt;&#x2F;div&gt;,</span><br><span class="line">        &#x2F;&#x2F; &lt;div&gt;&#123;arr&#125;&lt;&#x2F;div&gt;,</span><br><span class="line">        &lt;Msg name&#x3D;&quot;Leon&quot;&#x2F;&gt;,</span><br><span class="line">        document.getElementById(&#39;example&#39;)</span><br><span class="line">    );</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li><p>分析</p></li><li><p><code>ReactDOM.render(&quot;HTML&quot;, &quot;DOM&quot;)</code>  基本法，将模版转为HTML语言，并插入指定节点  </p></li><li><p><code>&lt;div&gt;{arr}&lt;/div&gt;</code>  变量是一个数组，结果 JSX 会把它的所有成员，添加到模板</p></li><li><p>组件</p></li></ul><p><strong>组件</strong>并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做<strong>虚拟 DOM</strong> （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM</p><ul><li>DOM diff 算法</li></ul><p>DOM的所有变动，都先在<strong>虚拟 DOM</strong> 上发生，然后再将实际发生变动的部分，反映在真实 DOM上，这种算法叫做 <strong>DOM diff</strong> ，它可以极大提高网页的性能表现</p><ul><li><p><code>React.createClass({})</code>  用于生成一个组件类，如 <code>Msg</code>，模板插入 <Msg /> 时，会自动生成 Msg 的一个实例  </p></li><li><p>组件注意事项： </p></li></ul><p>组件类的第一个字母必须大写;<br>只能包含一个顶层标签;<br>组件的属性可以在组件类的 <code>this.props</code> 对象上获取;<br><code>class</code> 属性需要写成 <code>className</code> ，<code>for</code> 属性需要写成 <code>htmlFor</code>  </p><ul><li><p>组件参数</p></li><li><p>组件属性  </p></li></ul><p><code>this.props</code> 表示那些一旦定义，就不再改变的特性  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    Msg &#x3D; React.createClass(&#123;</span><br><span class="line">        &#x2F;&#x2F; 判断传入参数是否符合要求</span><br><span class="line">        propTypes: &#123;</span><br><span class="line">            &#x2F;&#x2F; 限制参数为字符串</span><br><span class="line">            title: React.PropTypes.string.isRequired</span><br><span class="line">        &#125;,</span><br><span class="line">        &#x2F;&#x2F; 设置属性默认值</span><br><span class="line">        getDefaultProps: function()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                title: &quot;Hello Leon&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        render: function()&#123;</span><br><span class="line">            return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>组件状态</li></ul><p>组件看成是一个<strong>状态机</strong>，一开始有一个初始状态，然后用户互动，导致状态变化，从而触发重新渲染 UI  </p><p><code>this.state</code> 是会<em>随着用户互动而产生变化</em>的特性  </p><p>所以，该属性一般在应用在表单比较多  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    Slt_btn &#x3D; React.createClass(&#123;</span><br><span class="line">        &#x2F;&#x2F; 定义初始状态(对象)</span><br><span class="line">        getInitialState: function()&#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                opt: false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        clickSlt: function()&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                &#x2F;**</span><br><span class="line">                 * 修改状态值</span><br><span class="line">                 * 每次修改以后</span><br><span class="line">                 * 自动调用 this.render 方法再次渲染组件</span><br><span class="line">                 *&#x2F;</span><br><span class="line">                opt: !this.state.opt</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        render: function()&#123;</span><br><span class="line">            var text &#x3D; this.state.opt ? &quot;select&quot; : &quot;don&#39;t select&quot;;</span><br><span class="line">            return(</span><br><span class="line">                &lt;p onClick&#x3D;&#123;this.clickSlt&#125;&gt;</span><br><span class="line">                    You &#123;text&#125; this. Click to toggle!</span><br><span class="line">                &lt;&#x2F;p&gt;</span><br><span class="line">            )</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><ul><li>组件生命周期</li></ul><p>分别有：  </p><ol><li>Mounting：已插入真实 DOM</li><li>Updating：正在被重新渲染</li><li>Unmounting：已移出真实 DOM</li></ol><p>三种状态提供五种处理函数：  </p><ol><li><code>componentWillMount()</code>  组件<strong>载入之前</strong>调用</li><li><code>componentDidMount()</code>  组件<strong>载入之后</strong>调用</li><li><code>componentWillUpdate()</code>  组件<strong>更新之前</strong>调用</li><li><code>componentDidUpdate()</code>  组件<strong>更新之后</strong>调用</li><li><code>componentWillUnmount()</code>  组件<strong>卸载之前</strong>调用</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;革命性创新 性能出众 代码逻辑灰常简单的 React&lt;/p&gt;
&lt;h2 id=&quot;什么是React&quot;&gt;&lt;a href=&quot;#什么是React&quot; class=&quot;headerlink&quot; title=&quot;什么是React&quot;&gt;&lt;/a&gt;什么是React&lt;/h2&gt;&lt;p&gt;React 起源于Fac
      
    
    </summary>
    
    
      <category term="react jsx" scheme="https://h5m1007.github.io/categories/react-jsx/"/>
    
    
      <category term="react jsx" scheme="https://h5m1007.github.io/tags/react-jsx/"/>
    
  </entry>
  
  <entry>
    <title>NodeJs 全记录六</title>
    <link href="https://h5m1007.github.io/2016/10/31/learn-from-nodejs/"/>
    <id>https://h5m1007.github.io/2016/10/31/learn-from-nodejs/</id>
    <published>2016-10-31T06:03:00.000Z</published>
    <updated>2020-04-30T06:38:46.781Z</updated>
    
    <content type="html"><![CDATA[<p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p><h2 id="express"><a href="#express" class="headerlink" title="express"></a>express</h2><p>作为node框架express，基于connect构建而成，保持重用中间件的做法，更加便捷构建web应用  </p><h3 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h3><p>模版语言，用来分离逻辑代码和外在内容，使前后台设计时，对页面或逻辑改动时，相互不影响，更加分清前端和后台设计的工作  </p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>假设已安装模块 <code>npm install ejs</code> 和 <code>npm install superagent</code>  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- server.js --&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var express &#x3D; require(&#39;express&#39;),</span><br><span class="line">        search &#x3D; require(&#39;.&#x2F;search&#39;),</span><br><span class="line">        app &#x3D; express.createServer();</span><br><span class="line">    app</span><br><span class="line">        .set(&#39;view engine&#39;, &#39;ejs&#39;) &#x2F;&#x2F; 指明模版引擎</span><br><span class="line">        .set(&#39;views&#39;, __dirname + &#39;&#x2F;views&#39;) &#x2F;&#x2F; 指明模版根目录</span><br><span class="line">        .set(&#39;view options&#39;, &#123;</span><br><span class="line">            &#x2F;&#x2F; 参数值传递每个模版</span><br><span class="line">            layout: false</span><br><span class="line">        &#125;)</span><br><span class="line">        .set(&#39;view cache&#39;, true); &#x2F;&#x2F; 对模版缓存</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置路由处理器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    app.get(&#39;&#x2F;&#39;, function(req, res)&#123;</span><br><span class="line">        &#x2F;&#x2F; 渲染index模版</span><br><span class="line">        &#x2F;&#x2F; 并作为响应返回</span><br><span class="line">        res.render(&#39;index&#39;);</span><br><span class="line">        &#x2F;&#x2F; console.log(app.set(&#39;views&#39;));</span><br><span class="line">    &#125;);</span><br><span class="line">    app.get(&#39;&#x2F;search&#39;, function(req, res, next)&#123;</span><br><span class="line">        search(req.query.q, function(err, baikes)&#123;</span><br><span class="line">            &#x2F;&#x2F; req.query 获取地址栏传递的参数</span><br><span class="line">            if (err) &#123;</span><br><span class="line">                &#x2F;&#x2F; 调用search(qstr, fn)函数</span><br><span class="line">                &#x2F;&#x2F; 经fn实例化的错误中间件</span><br><span class="line">                return next(err);</span><br><span class="line">            &#125;</span><br><span class="line">            res.render(</span><br><span class="line">                &#39;search&#39;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &#x2F;&#x2F; 传递变量到search.ejs视图</span><br><span class="line">                    &#x2F;&#x2F; 这类变量称作本地变量</span><br><span class="line">                    &#x2F;&#x2F; 因只对其传递视图可见</span><br><span class="line">                    results: baikes,</span><br><span class="line">                    search: req.query.q</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 配置错误处理器</span><br><span class="line">     *&#x2F;</span><br><span class="line">    app.error(function(err, req, res, next)&#123;</span><br><span class="line">        &#x2F;&#x2F; 配置search(qstr, fn)函数</span><br><span class="line">        &#x2F;&#x2F; fn实例化的错误中间件参数</span><br><span class="line">        if(&#39;Bad baidu baike response&#39; &#x3D;&#x3D; err.message)&#123;</span><br><span class="line">            res.render(</span><br><span class="line">                &#39;error&#39;,</span><br><span class="line">                &#123;</span><br><span class="line">                    status: 500</span><br><span class="line">                &#125;,</span><br><span class="line">                function(err, html)&#123;</span><br><span class="line">                    &#x2F;&#x2F; 第三参数</span><br><span class="line">                    &#x2F;&#x2F; 可处理收到的html</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    app.listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p><code>express.createServer</code> 返回HTTP服务器自带配置系统  </p><p>调用对象 <code>app</code> 上的 <code>set()</code> 来修改默认配置项  </p><p>经express框架处理路由，省去了对 <code>req.url</code> 和 <code>req.method</code> 的判断  </p><p>express为response对象提供了 <code>render()</code> 渲染模版方法，渲染过程：  </p><p>| 初始化模版引擎  </p><p>| 读取视图文件并将其传递给模版引擎  </p><p>| 获取解析后的HTML页面并作为响应发送给客户端  </p><ul><li>结合使用模版语言 可选Ejs或jade  </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- index.ejs --&gt;</span><br><span class="line">&lt;h1&gt;Baike Search App&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;Please enter your search term:&lt;&#x2F;p&gt;</span><br><span class="line">&lt;form action&#x3D;&quot;&#x2F;search&quot; method&#x3D;&quot;GET&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;q&quot;&gt;</span><br><span class="line">    &lt;button&gt;Search&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure><p>表单里，提交到 <code>/search</code> ，所带参数有 <code>q=</code> input标签输入的内容，最终以 <code>search?q=xxx</code> 跳转到提交页面，而地址栏参数，可由 <code>req.query.q</code> 获取  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- search.ejs --&gt;</span><br><span class="line">&lt;h1&gt;Baidu Baike Search results for &lt;%&#x3D; search %&gt;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;% if (results.length) &#123; %&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;% for (var i &#x3D; 0; i &lt; results.length; i++) &#123; %&gt;</span><br><span class="line">        &lt;li&gt;&lt;%&#x3D; results[i].name %&gt; - &lt;em&gt;&lt;%&#x3D; results[i].value %&gt;&lt;&#x2F;em&gt;&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;% &#125; else &#123; %&gt;</span><br><span class="line">    &lt;p&gt;No resultes&lt;&#x2F;p&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><p>ejs模版语言，js代码嵌入<code>&lt;%</code>和<code>%&gt;</code>间，在<code>&lt;%</code>后加入<code>=</code>符号将变量打印出来  </p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><p>express为node的Request和Response对象提供了一系列扩展来简化开发  </p><ul><li><p><code>req.header(&#39;host&#39;)</code>  直接获取头信息</p></li><li><p><code>req.accepts(&#39;html&#39;)</code>  判断Accept头信息，返回布尔值</p></li><li><p><code>req.is(&#39;text/html&#39;)</code>  判断 <code>Content-Type</code> 头信息</p></li><li><p><code>res.header(&#39;content-type&#39;)</code>  判断指定值是否已在res上设置</p></li><li><p><code>res.send(500)</code>  直接发送状态码</p></li><li><p><code>res.send(&#39;&lt;p&gt;html&lt;/p&gt;&#39;)</code>  直接发送HTML</p></li><li><p><code>res.send({ obj: val })</code>  序列化对象为JSON对象，并设置 <code>Content-Type</code> 头信息</p></li><li><p><code>res.send([1, 2])</code>  序列化数组为JSON对象，并设置 <code>Content-Type</code> 头信息</p></li><li><p><code>res.json(5)</code>  显示地将内容转成JSON对象</p></li><li><p><code>res.redirect(&#39;/some/other/url&#39;)</code>  等价于发送状态码302及Location头信息  </p></li><li><p><code>res.sendfile(&#39;image.jpg&#39;)</code>  ；类似于<code>static</code>，不同于它用于单个文件  </p></li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><p><code>app.get(&#39;/&#39;, callback)</code></p><ul><li>自定义参数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    app.get(&#39;&#x2F;user&#x2F;:name&#39;, function(req, res, next)&#123;</span><br><span class="line">        return req.params.name &#x3D;&#x3D; &#39;leon&#39;; &#x2F;&#x2F; true</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">name变量会注入 &#96;req.params&#96; 请求参数对象上，匹配url如 &#96;&#x2F;user&#x2F;leon&#96;，而不会匹配到 &#96;&#x2F;user&#x2F;&#96;  </span><br><span class="line"></span><br><span class="line">&#96;app.get(&#39;&#x2F;user&#x2F;:name?&#39;)&#96; 当name变量后添加&quot;?&quot;时，将可以匹配到如 &#96;&#x2F;user&#96; 和 &#96;&#x2F;user&#x2F;leon&#96;  </span><br><span class="line"></span><br><span class="line">&#96;app.get(&#x2F;^\&#x2F;user&#x2F;([a-z\d\-]*)&#x2F;)&#96; 可使用正则匹配，将匹配字母、数字及中划线  </span><br><span class="line"></span><br><span class="line">- 强制匹配其它路由</span><br><span class="line">当一个路由匹配到并得到处理后，同时可以强制继续匹配其它路由</span><br></pre></td></tr></table></figure><script>    app.get('/user/:name', function(req, res, next){        if('leon' != req.params.name[0]) return next();    });</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 中间件</span><br><span class="line">与connect一样地使用中间件，如 &#96;express.static(__dirname)&#96; &#96;express.session()&#96;  </span><br><span class="line"></span><br><span class="line">同时，express允许在*特定匹配到的路由*下才能使用的中间件</span><br></pre></td></tr></table></figure><script>    function secure(req, res, next){        if(!req.session.logged_in){            return res.send(403); //未授权            // 跳过路由的其它中间件            // 直接到下一个路由做处理            // return next('route');         }    }    app.get(        '/finacials',        secure,        function(){}    )</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## express的加载方式</span><br><span class="line">选择一种代码组织策略，保证每个模块都是独立的，则就得确定好各模块的加载方式  </span><br><span class="line"></span><br><span class="line">- 第一种加载方式</span><br><span class="line">良好的代码组织方式应只维护一个 &#96;server.js&#96; 文件，而该文件包含有路由表，且每一部分路由处理器都通过模块化的方式引入  </span><br><span class="line"></span><br><span class="line">**server.js**</span><br></pre></td></tr></table></figure><script>    var express = require('express'),        pages = require('./pages'),        app = express.createServer();    app.get('/pages', pages.home);    app.get('/pages/list', pages.list);</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**pages.js**</span><br></pre></td></tr></table></figure><script>    exports.home = function(req, res, next){}    exports.list = function(req, res, next){}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">而第一种加载方式，会*出现的问题*是，每个模块引入时，都是指向同一个实例对象 &#96;exports&#96; ，也就是说 &#96;require(&#39;.&#x2F;pages&#39;)&#96; 该模块只能使用一次，因require只会加载一次该模块，不管后面有多少次使用了 &#96;require(&#39;.&#x2F;pages&#39;)&#96;    </span><br><span class="line"></span><br><span class="line">- 第二种加载方式</span><br><span class="line">可以看出，第一种加载方式模块间的**耦合度高**，而第二种加载方式通过一种解耦方式**app挂载**来降低模块间耦合度  </span><br><span class="line"></span><br><span class="line">**server.js**</span><br></pre></td></tr></table></figure><script>    // ...    app.use(require('./pages'));</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">**pages.js**</span><br></pre></td></tr></table></figure><script>    var app = module.exports = express.createServer();    app.get('/', function(req, res, next){});    app.get('/list', function(req, res, next){});</script><pre><code>把每个模块单独作为中间件让其它模块使用，这样模块本身就是完全独立的依赖、中间件、配置，等等  </code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs&lt;/p&gt;
&lt;h2 id=&quot;express&quot;&gt;&lt;a href=&quot;#express&quot; class=&quot;headerlink&quot; title=&quot;express&quot;&gt;&lt;/a&gt;express&lt;/h2&gt;&lt;p&gt;作为node框
      
    
    </summary>
    
    
      <category term="node javascript" scheme="https://h5m1007.github.io/categories/node-javascript/"/>
    
    
      <category term="node nodejs express" scheme="https://h5m1007.github.io/tags/node-nodejs-express/"/>
    
  </entry>
  
</feed>
