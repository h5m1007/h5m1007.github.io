<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> NodeJs 全记录二 · Leooon Blog</title><meta name="description" content="NodeJs 全记录二 - Leon"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Leooon Blog"><meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="Leooon Blog" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">NodeJs 全记录二</h1><div class="post-info">Oct 21, 2016</div><div class="post-content"><p>前端程序猿的第二春 使用老本行JS来构建服务器端的神器  NodeJs</p>
<h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><p>高并发指的是在同一个时间点，有多用户同时访问URL地址，如淘宝双11双12，就会产生高并发  </p>
<ul>
<li>后果<br>服务器被占满崩溃，数据存储、更新结果和理想设计不一样，如出现重复数据记录，多次添加用户记录。而对于用户来说，就是访问网站延迟，网站加载缓慢等等  </li>
</ul>
<h3 id="nodeJs处理高并发"><a href="#nodeJs处理高并发" class="headerlink" title="nodeJs处理高并发"></a>nodeJs处理高并发</h3><p>nodeJs引入一个概念，那就是“共享状态的并发”<br>面对的问题是，在对回调函数中修改<strong>当前</strong>内存中的变量(状态)需要多加考虑  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var arr &#x3D; [1, 2, 3];</span><br><span class="line">    function sevArr()&#123;</span><br><span class="line">        var html &#x3D; &quot;&lt;p&gt;&quot; + arr.join(&quot;+&quot;) + &quot;&lt;&#x2F;p&gt;&quot;;</span><br><span class="line"></span><br><span class="line">        arr &#x3D; []; &#x2F;&#x2F; 数组置空</span><br><span class="line"></span><br><span class="line">        return html;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>假设用户每次访问请求<code>/array</code>URL时，会执行<code>sevArr()</code>  </p>
<p>Node会这样处理，第一个请求是，带有数组用”+”连接后返回的字符串的完整html插入当前页面；第二个请求是，数组被置空。这里该注意的是，如果是php的话，两个请求都是完整html被插入页面  </p>
<p>这里，是因为node是采用一个长期运行的进程，相反，Apache会产生多个线程，且每次都是刷新状态，所以在php中解析器每次运行，变量<code>arr</code>都被重新赋值。但在node下，<code>sevArr</code>每次被调用，作用中的变量不受影响  </p>
<h2 id="阻塞和非阻塞IO"><a href="#阻塞和非阻塞IO" class="headerlink" title="阻塞和非阻塞IO"></a>阻塞和非阻塞IO</h2><p>在讨论前，先引入几个专名：单线程、任务队列、事件轮询(Event Loop)  </p>
<h3 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h3><p>因php写的服务器执行的是同步任务，会有阻塞线程的情况，如<code>sleep()</code>延迟函数会阻塞线程执行，当阻塞延迟时间未到，不会有任何操作，即同步的  </p>
<h3 id="非阻塞"><a href="#非阻塞" class="headerlink" title="非阻塞"></a>非阻塞</h3><p>而node相反，非阻塞异步<br>node使用的是<strong>事件轮询</strong>，与<code>sleep()</code>对应的<code>setTimeout()</code>在这里是非阻塞的  </p>
<h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p>js是单线程即一个时间内只能做一件事</p>
<h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p><strong>任务队列</strong>(task queue)  指一个事件的队列，一个消息队列<br>其中，进入队列的事件包括：IO设备(键盘输入、显示器打印机输出等)的事件、用户事件(鼠标点击、页面滚动等)，凡是有回调函数，这些事件触发前就会进入任务队列，待主线程读取</p>
<p>因js为单线程，所以所有任务需要排队进行，这是CPU空闲<br>所有任务分为<em>同步</em>和<em>异步</em>，同步指在主线程排队的任务需一个等一个结束地执行，而异步指任务不进入<strong>主线程</strong>，而是进入<strong>任务队列</strong>(task queue)</p>
<h3 id="事件轮询"><a href="#事件轮询" class="headerlink" title="事件轮询"></a>事件轮询</h3><p>在node中，并发、timeout及http等原生模块的IO一样采用事件轮询  </p>
<p>而事件轮询又指的是，<strong>主线程</strong>由<strong>任务队列</strong>读取事件，整个过程循环不断，这个运行机制称Event Loop  </p>
<ul>
<li>所有任务在主线程执行，从而形成一个<strong>执行栈</strong></li>
<li>与主线程并存的一个<strong>任务队列</strong>(task queue)，当异步任务运行有结果，则在<strong>任务队列</strong>放置一个事件</li>
<li>当<strong>执行栈</strong>完成所有同步任务，则会接着读取<strong>任务队列</strong>，检查队列里哪些事件对应哪些异步任务，让事件进入<strong>执行栈</strong>并执行</li>
<li><strong>主线程</strong>循环不停以上三步操作 –&gt; <strong>事件轮询</strong></li>
</ul>
<p><img src="http://image.beekka.com/blog/2014/bg2014100802.png" alt="Event Loop"></p>
<p>如图所示，主线程运行后产生堆(heap)栈stack，栈中代码(同步任务)调用各种外部API，它们在<strong>任务队列</strong>加入各种对应的事件，待栈中代码执行完毕，主线程就读取<strong>任务队列</strong>(异步任务)中事件对应的回调函数</p>
<h3 id="node事件轮询"><a href="#node事件轮询" class="headerlink" title="node事件轮询"></a>node事件轮询</h3><p>nodejs同为单线程事件轮询，其机制与浏览器有所不同，如图  </p>
<p><img src="http://image.beekka.com/blog/2014/bg2014100803.png" alt="NodeJs Event Loop"></p>
<ul>
<li>经Chrome V8引擎解析js</li>
<li>解析后代码经node的API</li>
<li>接着libuv库来负责node Api 执行，由它来将不同任务分发个不同线程，从而构成事件轮询，异步方式将任务执行结果又回到V8</li>
</ul>
<h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><p>来观察下<strong>定时器</strong>，原生js的setTimeout()和node的两个process.nextTick(func)及setImmediate(func)，同样控制其任务的执行顺序  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    &#x2F;*</span><br><span class="line">        setTimeout(func, 0)</span><br><span class="line">        timer0和timer1属于同一级事件轮询</span><br><span class="line">        timer0 --&gt; timer1 --&gt; timer2</span><br><span class="line">    *&#x2F;</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">     console.log(&quot;timer0&quot;);</span><br><span class="line">     setTimeout(function()&#123;</span><br><span class="line">         console.log(&quot;timer2&quot;);</span><br><span class="line">     &#125;, 0);</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(&quot;timer1&quot;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">        process.nextTick(func)</span><br><span class="line">        把原本应在第二次事件轮询的timer2</span><br><span class="line">        放到了第一次事件轮询上</span><br><span class="line">        因此 timer0 --&gt; timer2 --&gt; timer1</span><br><span class="line">    *&#x2F;</span><br><span class="line">    process.nextTick(function A()&#123;</span><br><span class="line">     console.log(&quot;timer0&quot;);</span><br><span class="line">     process.nextTick(function B()&#123;</span><br><span class="line">         console.log(&quot;timer2&quot;);</span><br><span class="line">     &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">      console.log(&quot;timer1&quot;);</span><br><span class="line">    &#125;, 0);</span><br><span class="line"></span><br><span class="line">    &#x2F;*</span><br><span class="line">        setImmediate(func)</span><br><span class="line">        把事件注册到下一次事件轮询上</span><br><span class="line">        因此 timer0 --&gt; timer1 --&gt; timer2</span><br><span class="line">    *&#x2F;</span><br><span class="line">    setImmediate(function()&#123;</span><br><span class="line">        setImmediate(function A()&#123;</span><br><span class="line">            console.log(&quot;timer0&quot;);</span><br><span class="line">            setImmediate(function B()&#123;</span><br><span class="line">                console.log(&quot;timer2&quot;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        setTimeout(function timeout()&#123;</span><br><span class="line">            console.log(&quot;timer1&quot;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>从代码可知，  <code>process.nextTick(func)</code>  可让指定任务在所有异步任务之前发生，会在<em>下一次事件轮询前</em>触发回调<br>而  <code>setImmediate(func)</code>  可让指定任务在<em>下一次事件轮询时</em>发生，类似于  <code>setTimeout(func, 0)</code>  </p>
<ul>
<li>小结<br><code>process.nextTick(func)</code>  指定的回调在本次事件轮询触发，  <code>setImmediate(func)</code>  指定的回调在下次事件轮询触发，因此前者比后者发送早，效率高，不用检查队列  </li>
</ul>
<h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>node对于错误处理格外重视，一旦遗漏某个错误，当发生后会很难追踪，因调用信息的上下文丢失  </p>
<p>因node应用置于一个拥有大量<strong>共享状态</strong>的大进程里，所以一旦如HTTP请求的某个回调发生错误，整个进程崩溃  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">    http.createServer(function()&#123;</span><br><span class="line">     throw new Error(&quot;错误未被捕获！&quot;);</span><br><span class="line">    &#125;).listen(8080);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>代码所示错误未经  <code>try{} catch(e){}</code>  来捕获，当访问服务器进程崩溃  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Error: 错误未被捕获！</span><br><span class="line">  at Server.&lt;anonymous&gt; (..\deal-error.js:3:8)</span><br><span class="line">  at emitTwo (events.js:87:13)</span><br><span class="line">  at Server.emit (events.js:172:7)</span><br><span class="line">  at HTTPParser.parserOnIncoming [as onIncoming] (_http_server.js:533:12)</span><br><span class="line">  at HTTPParser.parserOnHeadersComplete (_http_common.js:103:23)</span><br></pre></td></tr></table></figure>

<ul>
<li>uncaughtException事件<br>使用该事件处理器后，未被捕获的错误将不会导致进程崩溃，且后续操作可控  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">    http.createServer(function()&#123;</span><br><span class="line">        throw new Error(&quot;错误未被捕获！&quot;);</span><br><span class="line">    &#125;).listen(8080);</span><br><span class="line">    process.on(&#39;uncaughtException&#39;, function(err)&#123;</span><br><span class="line">        console.error(err);</span><br><span class="line">        process.exit(1); &#x2F;&#x2F; 手动关闭进程</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="堆栈跟踪"><a href="#堆栈跟踪" class="headerlink" title="堆栈跟踪"></a>堆栈跟踪</h2><p>堆栈跟踪指的是错误发生后，在后台显示的一系列函数调用信息，如  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function c()&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;;</span><br><span class="line">    function b()&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;;</span><br><span class="line">    function a()&#123;</span><br><span class="line">        &#x2F;*</span><br><span class="line">            未引入捕获代码块</span><br><span class="line">            进程将会直接中断</span><br><span class="line">        *&#x2F;</span><br><span class="line">        throw new Error(&#39;here&#39;);</span><br><span class="line">    &#125;;</span><br><span class="line">    c();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>后台显示的调用信息，从下至上可发现其调用路径  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Error: here</span><br><span class="line">    at a (..\stack-trace.js:10:8)</span><br><span class="line">    at b (..\stack-trace.js:6:2)</span><br><span class="line">    at c (..\stack-trace.js:2:2)</span><br><span class="line">    at Object.&lt;anonymous&gt; (..\stack-trace.js:13:1)</span><br><span class="line">    at Module._compile (module.js:409:26)</span><br><span class="line">    at Object.Module._extensions..js (module.js:416:10)</span><br><span class="line">    at Module.load (module.js:343:32)</span><br><span class="line">    at Function.Module._load (module.js:300:12)</span><br><span class="line">    at Function.Module.runMain (module.js:441:10)</span><br><span class="line">    at startup (node.js:139:18)</span><br></pre></td></tr></table></figure>

<p>而当引入<strong>定时器</strong>后，将会<em>增多一次事件轮询</em>  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    function c()&#123;</span><br><span class="line">        b();</span><br><span class="line">    &#125;;</span><br><span class="line">    function b()&#123;</span><br><span class="line">        a();</span><br><span class="line">    &#125;;</span><br><span class="line">    function a()&#123;</span><br><span class="line">        try&#123;</span><br><span class="line">            &#x2F;*</span><br><span class="line">                引入捕获代码块</span><br><span class="line">                进程不中断且后续操作可控</span><br><span class="line">            *&#x2F;</span><br><span class="line">            setTimeout(function()&#123;</span><br><span class="line">                throw new Error(&#39;here&#39;);</span><br><span class="line">            &#125;, 10);</span><br><span class="line">        &#125;catch(e)&#123;</span><br><span class="line">            console.log(&#39;捕获到错误！&#39; + e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    c();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Error: here</span><br><span class="line">    at null._onTimeout (..\stack-trace.js:12:10)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:92:15)</span><br></pre></td></tr></table></figure>

<p>增多一次轮询将会丢失一部分有价值的函数调用信息  </p>
</div></article></div></main><footer><div class="paginator"><a href="/2016/10/23/learn-from-nodejs/" class="prev">上一篇</a><a href="/2016/10/19/learn-from-nodejs/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://yoursite.com">Leon</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>